{"meta":{"title":"blog","subtitle":"日常工作学习的一些简单记录，粗俗浅显。","description":"日常工作学习的一些简单记录，粗俗浅显。","author":"Qiong Qiong Woo","url":"https://github.com/qiongqiongwoo"},"pages":[],"posts":[{"title":"浏览器渲染","slug":"浏览器渲染","date":"2018-12-14T06:21:42.000Z","updated":"2019-01-04T09:06:41.000Z","comments":true,"path":"2018/12/14/浏览器渲染/","link":"","permalink":"https://github.com/qiongqiongwoo/2018/12/14/浏览器渲染/","excerpt":"","text":"1、浏览器是多进程的比如chrome browser进程：与用户交互、浏览器的前进后退、各个tab页面的管理等 GPU进程：3D页面绘制等 浏览器渲染进程（Render进程，其内部是多线程的）每个tab对应一个，相互独立。2、如上所述Render进程是多线程的 JS引擎线程—– 主线程（JS内核负责解析和运行代码，一个Render进程只有一个JS引擎线程） GUI渲染线程：负责渲染浏览器界面，当界面需要repaint或者reflow时就会执行。 事件触发线程：事件被触发时，将事件添加到事件处理队列等待JS引擎被执行。 定时触发线程：setTimeout、setInterval所在线程 异步请求线程：XMLHttpRequest在连接后通过浏览器开一个线程请求3、JS引擎和渲染引擎之间的关系 JS引擎线程和GUI渲染线程是互斥的，JS引擎执行时，GUI渲染线程会被挂起。 JS引擎花费时间过多时，会出现浏览器卡死的情况。 JS是单线程是指解释和执行JS的线程只有一个，即主线程、JS引擎线程。4、JS的运行机制如下 所有的同步任务都在主线程上执行，形成一个函数执行栈 主线程之外有个任务队列 一旦stack为空，主线程就去读取任务队列中的异步任务进行执行 主线程循环重复上面三个步骤 事件触发线程注册函数，当事件触发时，被推入event loop（消息队列的形式，消息队列中每一条信息都对应着一个事件） 主线程函数栈执行完后，循环从消息队列中取消息进行处理5、web worker &amp; share worker JS引擎向浏览器申请开一个子线程做一些耗时处理（此子线程不能操作dom，完全受JS引擎的控制） share worker是浏览器的多个tab共享的，web worker属于单独的一个tab6、宏任务（macro-task）和微任务(micro-task)的执行 宏任务： script\\setTimeout\\setTimeInterval\\setTimeImmediate\\ 微任务： promise、process.nextTick、mutationObserver 根据html standard，在每个macro-task执行完之后，UI都会重新渲染，如果再micro-task中完成数据的处理，则当前task执行完之后就可以得到最终的UI，但如果在一个新的task中进行执行，需要两次渲染才能得到最终的UI，这也是promise要好于setTimeOut的地方。12345678910111213setTimeout(function()&#123; console.log('定时器开始啦’) &#125;); new Promise(function(resolve)&#123; console.log('马上执行for循环啦’); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125; &#125;).then(function()&#123; console.log('执行then函数啦’) &#125;); console.log('代码执行结束’); // 浏览器的执行结果为 马上执行for循环啦 -&gt; 代码执行结束 -&gt; 执行then函数啦 -&gt; 定时器开始啦1.整体script作为第一个宏任务进入主线程，这是第一轮宏任务。2.遇到setTimeout，其回调函数被分发到宏任务Event Queue中，这是第二个宏任务。3.继续执行，打印【马上执行for循环啦】4.遇到promise.then()微任务，这是第一轮宏任务下的微任务，因为整体script是第一轮宏任务嘛5.继续执行，打印【代码执行结束】6.现在整体script作为第一轮宏任务，去检查这一轮下的微任务，发现有一个promise.then()，去执行它（至此现在第一轮宏任务，以及这一轮宏任务下的微任务都被执行过了）7.开始第二轮宏任务，发现宏任务队列里有一个setTimeout，执行它，就打印了【定时器开始啦】// 注意： node中的执行结果和上面是不同的7、浏览器渲染流程style Tree的结构 Dom树构建的过程包括符号化和构建树两个过程，符号化采用符号识别算法 DomContentLoaded仅当dom加载完成不包括样式表，onload事件是dom、样式、图片、脚本全都执行完毕了 从上图可以看到、Css的加载不会阻塞dom树的解析但会阻塞render树的渲染 Web模式是同步的，遇到script标签，会执行完js再进行后续的解析，遇到引用外部的script，同样会等到js下载完，这样会阻塞后续的资源下载，因此出现了预解析。 预解析分析引用的外部资源，同步进行下载以提高速度，但并不构建dom树。 渲染树和dom树不是一一对应的，不可见的dom元素不会插入到渲染树中，display为none的元素也不会插入。8、dom树的构建过程 二进制字节流 — -1—&gt; 字符流 —–2—-&gt; 词语 ——-3–&gt; 多个节点 -—-4——-&gt;Dom树 1是根据页面的编码格式， 2根据词法分析（基于状态机的符号识别算法） 4可以利用栈（所有的标签都是闭合的），3是存储类似于 在步骤3中会识别出全局的JavaScript代码，此时dom树尚未创建，因此不能访问dom。9、layout(reflow)和repaint，layout就是计算元素的大小位置等信息，确定每个元素在页面上的位置 Layout(reflow):表示元素的内容、结构、尺寸位置发生了变化，需要重新计算样式和渲染树 repaint:元素的背景色、边框文字颜色发生变化。 reflow的成本要高于repaint，应该尽量避免reflow，回流一定伴随着重绘，重绘却会单独出现10、引起layout（reflow）的情况 dom结构改变比如删除一个节点 render树变化，比如padding变化 窗口resize font字体大小发生变化 获取一些属性时会引发回流，比如： offset（height/width…）、scroll（height/width…）、client（height/width…）,width，height，getComputedStyle等12345678var s = document.body.style;s.padding = \"2px\"; // 回流+重绘s.border = \"1px solid red\"; // 再一次 回流+重绘s.color = \"blue\"; // 再一次重绘s.backgroundColor = \"#ccc\"; // 再一次 重绘s.fontSize = \"14px\"; // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode('abc!')); 11、reflow的优化方案 style的改变一次性改，比如通过class改变 避免循环添加dom，统一处理一次添加 将复杂的元素绝对或者固定定位，脱离文档流，减少回流代价12、防止浏览器卡死的方式 优化循环 12345678910111213function chunk(array, process, context) &#123; setTimeout(function inner() &#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0) &#123; setTimeout(inner, 100); &#125; &#125;, 100);&#125; // 此处递归操作直接用inner 而不是直接调用chunk的原因如下：Var chunkObj = chunkchunObj(array, process, context) // 可以正常执行chunk = function(array, process, context) &#123; console.log(‘fadfdasfds’)&#125;chunObj(array, process, context) // 不能正常执行，其内部的 chunk已经被新的定义替代 如果函数体内有不相干的、执行也没有先后的操作，则可以用chunk方式进行拆分或者直接交给浏览器去调度 1234567891011121314151617181920function doSomething()&#123; setTimeout（dosomething1, 0） setTimeout（dosomething2, 0）&#125;* 优化递归操作function fac(num) &#123; var tmp = &#123;&#125; return (function fn(n)&#123; var res; if (tmp[n])&#123; res= tmp[n]; console.log('match'+n) // 此处通过暂存数据，将减少递归层次， 这种优化牺牲了空间，还有一种方式是中间的结果不暂存， 利用迭代操作进行优化。 &#125; else &#123; if(n &lt;= 1) res = 1; else res = fn(n-2) + fn(n-1) &#125; tmp[n] = res; return res; &#125;)(num)&#125; 减少dom操作： 例如改变style的三个值不如通过设置一个class效率更高13、外链css的下载会阻塞JS的执行 1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;script&gt; function printH2() &#123; console.log('first script', document.querySelectorAll('h2')); &#125; printH2() setTimeout(printH2) // JS脚本之前如果没有css标签，这部分的执行是不会被阻塞的 &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/4.0.0-alpha.4/css/bootstrap.css\"&gt; &lt;h2&gt;World&lt;/h2&gt; &lt;script&gt; console.log('second script’); // 此处的执行会受到css的下载的影响 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 14、两个js的执行并非等到完全下载完1234&lt;body&gt;&lt;script src=\"1.js\"&gt;&lt;/script&gt; // 如果1下载5s， 2下载10s，1在5s后执行，2在10s后执行&lt;script src=\"2.js\"&gt;&lt;/script&gt; // 如果1下载10s， 2下载5s, 1在10s后执行，1执行完再执行2&lt;/body&gt; 15：渲染过程的一个例子（一下为firefox的例子）123456789&lt;doc&gt;&lt;title&gt;A few quotes&lt;/title&gt;&lt;para class=\"emph\"&gt; Franklin said that &lt;quote&gt;\"A penny saved is a penny earned.\"&lt;/quote&gt;&lt;/para&gt;&lt;para&gt; FDR said &lt;quote&gt;\"We have nothing to fear but &lt;span class=\"emph\"&gt;fear itself.&lt;/span&gt;\"&lt;/quote&gt;&lt;/para&gt;&lt;/doc&gt; css 规则如下：1234 /* rule 1 */ doc &#123; display: block; text-indent: 1em; &#125;/* rule 2 */ title &#123; display: block; font-size: 3em; &#125;/* rule 3 */ para &#123; display: block; &#125;/* rule 4 */ [class=\"emph\"] &#123; font-style: italic; &#125; 对应的dom树、css规则树以及style context tree分别为：(此段描述的未 attachment的过程：其实就是dom树上的每个节点，找到其对应的style的过程) css rule tree结构为（css rule tree是根据dom树构建出来的，所以4节点有两个 CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去 chrom中不存在规则树，他直接将节点的style存在了dom树的节点上 接下来开始计算CSS样式（每个dom节点的）—&gt;构建Render Tree -&gt; Layout(定位坐标和大小，换行、position, overflow, z-index等）—&gt;composition -&gt; paint","categories":[],"tags":[{"name":"浏览器渲染","slug":"浏览器渲染","permalink":"https://github.com/qiongqiongwoo/tags/浏览器渲染/"}]},{"title":"整理的css知识","slug":"整理的css知识","date":"2018-12-14T05:01:21.000Z","updated":"2019-01-04T04:08:34.000Z","comments":true,"path":"2018/12/14/整理的css知识/","link":"","permalink":"https://github.com/qiongqiongwoo/2018/12/14/整理的css知识/","excerpt":"","text":"css标准地址 https://www.w3.org/TR/CSS2/visuren.html#inline-formatting1、block、inline、inline-block每个页面元素都有一个display属性，每个元素的display属性都有一个默认值，比如div的display属性为block，span的display属性为inline，inline元素不会自动换行且没有宽和高、block元素有宽和高度，且会自动换行。常见的元素分类如下：（1）block元素：body form textarea h1 - h6 html table button p ul ol div（2）inline元素：title span a em b strong I map 等（3）inline-block元素：img input td select textarea label区别方式为：是否可以设置宽、高、margin、padding值、是否会换行。对inline元素这只padding-top padding-bottom margin-bottom margin-top不会对周边元素产生影响，会加大自身的范围。2、嵌套规则：（1）块状元素可以包含内联元素或者块元素，内连元素不可以包含块元素只包含内连元素123&lt;a href=\"#\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; — 正确&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; — 正确&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; — 正确 （2）h1- h6、p、 dt这几个块元素只能包含内联元素或者可变元素12&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; -- wrong&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; — wrong （3）特殊的li标签内可以出现div标签（4）块级元素可以与块级元素并列、内联元素可以和内联元素并列123&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; — right&lt;div&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; — right&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; -- wrong 3、inline元素改为block元素的方式（1）直接将display值设置为block/inline-block（2）直接将position设置为absolute或者fix4、inline-block元素出现缝隙的解决方式（1）两个inline-block元素之间不能出现换行、空格等（2）设置margin-right值为负值（3）将父元素的font-size、letter-spacing、word-spacing值5、block元素内的inline-block元素出现底部空白或者两个inline-block元素无法对齐的情况（1）使用vertical-align：top（2）例子： https://segmentfault.com/a/11900000109349286、em: 相对于父级元素font-size的比例。rem：相对于根元素html的font-size比例。ex：所用字体中x的高度，通常取em的一半。7、css的三种定位机制：普通流、浮动和绝对定位。position有relative、absolute、fix、staticrelative：相对于元素应该出现的位置的相对位置。absolute：绝对定位的盒子是相对于离他最近的一个已定位的盒子进行定位的，可能是relative，可能是absolute。默认是body。浮动和绝对定位都将元素剥离了文档流。8、background-origin: 取值可以为content-box、padding-box、border-box，规定背景图放置的位置。9、box盒子模型（1）ie设置的height和 width = margin + padding +content-width（2）标准的盒子模型的 width = content-width（3）css3中加了一个属性叫box-sizing 来区分上面的情况（content-box \\ border-box \\ padding-box）10、formatting context: 它是页面中的一块渲染区域、并且有自己的一套渲染规则、他决定了元素如何定位以及与其他元素如何相互作用。常见的类别有：（1）BFC (block formatting context) BFC是一个独立的区域，不受外部元素影响也不影响外部元素 只有块级元素参加 box会在垂直方向上一个接一个的放置 属于同一个BFC的相邻的两个box的margin会重叠 计算BFC高度时，浮动元素也参与计算 每个元素的margin box的左边与包含块的border box的左边相接处，存在浮动也是如此会生成BFC的方式： 根元素比如body float不为none position为absolute或者fixed display为inline-block、table-cell、table-caption、flex、inline-flex overflow为hidden、scroll、auto例子： https://www.jianshu.com/p/66632298e355（2）IFC (inline formatting context) 只会在一个块级元素中只包含内连级别元素时才会生成。 行内级元素（inline-level element）的display为inline、inline-block、inline-table 行内级元素生成行内盒（inline-level box），参与行内格式化上下文 行框的宽度由其内部包含的块以及浮动元素所决定 如果几个行内框无法放入一个行框内，他们可能分配在两个或者多个垂直的行框内 同一个行内框如果不能放入一个行框内，也会分配到多个垂直的行框 行框的高度可以容纳所包含的框，对齐标准为vertical-align（此处会引入下面的12问题）（3）GFC（4）FFC11、line-height: 设置行间的距离，可以设置的方式（1）number：以当前的字体属性值来设置行高(不同的浏览器默认值不同， 介于1 - 1.2之间)（2）百分比：以当前字体属性的百分比来设置（3）length：固定的值12、vertical-align: 默认值为baseline，即按照基线进行对齐，此值是和line-height相关的。（1）css中对基线的定义为：inline-block元素的基线是标准流中最后一个行框的基线， 除非这个行框没有行盒子或者本身overflow属性计算值不是visible，这种情况下，基线是该元素margin底边缘。（2）inline元素有两个高度：和字体相关的content-area，以及实际区域virtual-area（line-height）","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://github.com/qiongqiongwoo/tags/css/"}]},{"title":"compose的执行和实现方式","slug":"compose的执行和实现方式","date":"2018-12-13T07:11:11.000Z","updated":"2019-01-04T04:04:02.000Z","comments":true,"path":"2018/12/13/compose的执行和实现方式/","link":"","permalink":"https://github.com/qiongqiongwoo/2018/12/13/compose的执行和实现方式/","excerpt":"","text":"compose：执行一系列任务的函数 tasks = [ step1, step2, step3… ] Bulleted List 执行顺序从右到左边 第一个函数的参数可以是多个，后面的函数参数只能是一个 函数的执行是同步的 let init = (…args) =&gt; args.reduce((ele1, ele2) =&gt; ele1 + ele2, 0)let step2 = (val) =&gt; val + 2let step3 = (val) =&gt; val + 3let step4 = (val) =&gt; val + 4输出： 15 compose的实现（1）lodash中的实现123456789101112131415161718var flow = function（funcs）&#123; Var length = funcs.length Var index = length while (index--) &#123; if (typeof funcs[index] !== 'function') &#123; throw new TypeError('Expected a function'); &#125; &#125; Return function(…args) &#123; var index = 0 var result = length ? funcs[index].apply(this, args) : args[0] while (++index &lt; length) &#123; result = funcs[index].call(this, result) &#125; return result &#125;&#125; （2）promise实现compose12345678910const compose = function(…funcs) &#123; let init = funcs.pop() return function(...arg) &#123; return funcs.reverse().reduce(function(sequence, func) &#123; return sequence.then(function(result) &#123; return func.call(null, result) &#125;) &#125;, Promise.resolve(init.apply(null, arg))) &#125;&#125;","categories":[],"tags":[{"name":"js, node, compose","slug":"js-node-compose","permalink":"https://github.com/qiongqiongwoo/tags/js-node-compose/"}]},{"title":"客户端http请求的header信息","slug":"客户端http请求的header信息","date":"2018-12-12T07:41:21.000Z","updated":"2019-01-04T02:56:21.000Z","comments":true,"path":"2018/12/12/客户端http请求的header信息/","link":"","permalink":"https://github.com/qiongqiongwoo/2018/12/12/客户端http请求的header信息/","excerpt":"","text":"1、HTTP请求方式GET：向Web服务器请求一个文件POST：向Web服务器发送数据让Web服务器进行处理PUT：向Web服务器发送数据并存储在Web服务器内部HEAD：检查一个对象是否存在DELETE：从Web服务器上删除一个文件CONNECT：对通道提供支持TRACE：跟踪到服务器的路径OPTIONS：查询Web服务器的性能请求说明：主要使用到“GET”和“POST”。实例：POST /test/tupian/cm HTTP/1.1分成三部分：（1）POST：HTTP请求方式（2）/test/tupian/cm：请求Web服务器的目录地址（或者指令）（3）HTTP/1.1: URI（Uniform Resource Identifier，统一资源标识符）及其版本 2、Host说明：请求的web服务器域名地址实例：例如web请求URL：http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cmHost就为zjm-forum-test10.zjm.baidu.com:8088 3、User-Agent说明：HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。实例：User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 4、Accept说明：指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。实例：例如：Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,/;q=0.5备注：在Prototyp（1.5）的Ajax代码封装中，将Accept默认设置为“text/javascript, text/html, application/xml, text/xml, /”。这是因为Ajax默认获取服务器返回的Json数据模式。在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。 5、Accept-Language说明：指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。实例：Accept-Language: zh-cn,zh;q=0.5这里默认为中文。 6、Accept-Encoding说明：指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。实例：Accept-Encoding: gzip,deflate备注：其实在百度很多产品线中，apache在给客户端返回页面数据之前，将数据以gzip格式进行压缩。另外有关deflate压缩介绍：http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html 7、Accept-Charset说明：浏览器可以接受的字符编码集。实例：Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7 8、Content-Type说明：显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。实例：Content-type: application/x-www-form-urlencoded;charset:UTF-8有关Content-Type属性值可以如下两种编码类型：（1）“application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。（2）“multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。当提交为单单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。一般在开发过程，是由前端工程与后端UI工程师商量好使用什么字符编码格式来post提交的，然后后端ui工程师按照固定的字符编码来解析提交的数据。所以这里设置的charset没有多大作用。 9、Connection说明：表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。实例：Connection: keep-alive 10、Keep-Alive说明：显示此HTTP连接的Keep-Alive时间。使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。以前HTTP请求是一站式连接，从HTTP/1.1协议之后，就有了长连接，即在规定的Keep-Alive时间内，连接是不会断开的。实例：Keep-Alive: 300 11、cookie说明：HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 12、Referer说明：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面服务器端返回HTTP头部信息1、Content-Length说明：表示web服务器返回消息正文的长度2、Content-Type:说明：返回数据的类型（例如text/html文本类型）和字符编码格式。实例：Content-Type: text/html;charset=utf-83、Date说明：显示当前的时间","categories":[],"tags":[{"name":"header, http request, htttp options","slug":"header-http-request-htttp-options","permalink":"https://github.com/qiongqiongwoo/tags/header-http-request-htttp-options/"}]}]}