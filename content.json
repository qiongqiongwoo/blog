{"meta":{"title":"blog","subtitle":"普普通通小码农的日常工作学习的一些粗俗浅显的记录。","description":"普普通通小码农的日常工作学习的一些粗俗浅显的记录。","author":"Qiong Qiong Woo","url":"https://qiongqiongwoo.github.io/blog"},"pages":[],"posts":[{"title":"call和apply以及this的指向深入","slug":"call和apply以及this的指向深入","date":"2018-12-24T07:14:37.000Z","updated":"2019-01-04T10:21:46.000Z","comments":true,"path":"2018/12/24/call和apply以及this的指向深入/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/24/call和apply以及this的指向深入/","excerpt":"","text":"1、call的一种实现， apply的实现同下，唯一不同的是传入的arguments是全部的变量数组1234567891011121314151617var a = &#123; name: 'zhangsan'&#125;var b = function(age) &#123;console.log(this.name)console.log(age)&#125;Function.prototype.call2 = function(context)&#123; // call 和 apply的作用 是在 要绑定的obj上添加一个fn， fn为当前要执行的fn，通过执行obj.fn改变真正执行时候的this context.fn = this var args = Array.prototype.slice.call(arguments,1); var result = context.fn(...args) delete context.fn return result&#125;b.call2(a, '23') 2、执行上下文：js引擎在执行一段代码之前，会将当前代码中用到的变量、函数以及this放到一个object中。12345678910111213141516171819202122232425262728var a = 1;function fun() &#123; 'use strict'; var a = 2; return this.a;&#125;fun();//严格模式下函数中的this为undefined，非严格模式下this = window （非严格模式下this为undefined时会默认指向window）var a = 1;Var obj = &#123; a: 2, b: function()&#123; function test()&#123; console.log(this.a) &#125; test() &#125;&#125;obj.b() // 同样在输出为1 而不是2var a = 1;Var obj = &#123; a: 2, b: function()&#123; console.log(this.a) &#125;&#125;Obj.b() // this为obj，输出为2var t = obj.bt() // 输出为1 此时代码执行的上下文为window 3、箭头函数的this是不变的123456789101112131415var a = 1;var obj = &#123; a: 2&#125;;var fun = () =&gt; console.log(this.a); // 箭头函数会捕获当前上下文的this作为执行的this并且保持不变，此处为windowfun();//1fun.call(obj)//1function Fun() &#123; this.name = 'Damonare';&#125;Fun.prototype.say = () =&gt; &#123; console.log(this);&#125;var f = new Fun();f.say();//window say在定义时已经确定上下文是window 4、构造函数中的this代表实例对象12345678910function Fun() &#123; this.name = &apos;Damonre&apos;; this.age = 21; this.sex = &apos;man&apos;; this.run = function () &#123; return this.name + &apos;正在跑步&apos;; &#125;&#125;var a = new Fun();a.run() // Damonre 5、12345678function Fun() &#123; this.name = 'Damonare'; this.say = () =&gt; &#123; console.log(this); &#125;&#125;var f = new Fun();f.say();//Fun的实例对象 此时的箭头函数的上下文为构造函数，构造函数的上下文为实例对象 6、执行执行上下文的创建流程（1）默认是全局上下文global context， 每遇到一个函数会创建一个函数执行上下文，进入栈， 只有在栈顶时才会激活执行上下文。（2）闭包的执行上下文创建过程123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); 通过闭包的作用域链可以发现，innerFoo在全局中保留了一个引用，导致未被回收。（3）一个执行上下文的结构如下：执行过程中对属性的查找是按照作用域链条进行查找，并且查找过程是不可逆的， 只能向后查找，因此全局的无法访问内部函数的变量。1234567891011var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; console.log(f); // f最后没查找到， 返回为undefined。 return a + b + c; // 此处对a的访问，首先查找AO(innerTest),然后查找AO(test), 最后查找vo(global)查找到。 &#125; return innerTest();&#125;test();","categories":[],"tags":[]},{"title":"JS中的概念总结","slug":"js中概念总结","date":"2018-12-23T10:32:12.000Z","updated":"2019-01-04T09:57:19.000Z","comments":true,"path":"2018/12/23/js中概念总结/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/23/js中概念总结/","excerpt":"","text":"1、call、apply、bind的区别 call apply 和bind都是用来改变this的指向的 call 和 bind都是顺序传参数，apply是传数组 利用call和apply会直接执行当前函数，bind不会2、reduce是es5中的内容1234var arr=“qweqrq\"var info= arr.split('').reduce((a,b)=&gt; (a[b]++ || (a[b]=1),a),&#123;&#125;)console.log(info) 3、forEach、 map 、 reduce的区别 forEach 方法是将数组中的每一个值取出做一些程序员想让他们做的事情 map 方法 是将数组中的每一个值放入一个方法中做一些程序员想让他们做的事情后返回一个新的数组 reduce 方法 将数组中的每一个值与前面的被返回相加的总和(初试值为数组的第一个值或者initialValue 4、async await 以及promisepromise解决的是回调场景中的状态处理问题，async/await解决的是回调嵌套的问题。（1）async是声明在回调环境函数（2）await是运行在等待回调结果过程中（3）promise是封装了回调操作的原子任务 5、require import &amp; export &amp; moudle.exports（1）node中用的是commonJs规范，export和require（2）为了在客户端使用，因此有了amd和cmd规范，二者都是异步加载，唯一不同的是依赖的模块执行的时机不同，amd是一边加载一边执行，cmd是加载完后才执行。（3）es6中的规范是export和import，但由于commonJs深入人心，因此还是有很多人使用commonJs规范。（4）require可以出现在代码中，import只能在代码的最顶层 6、JS异步的实现方式（1）回调 =&gt; 容易出现多重嵌套的问题，代码可读性差（2）事件监听（on和fire）（3）发布和订阅（4）promise对象（5）es6中的新加的generate1234Function *gen(x) &#123; var y = yield x + 2; return y;&#125; generator函数函数名和function之间加*，所有的执行片段用yield分割。函数的返回值是一个iterator，每次调用next就返回当前当前yield片段的值。适合于返回值有多个状态的情况。（6）es7中的await和async 7、json和jsonp的区别：json是一种数据格式、jsonp是一种跨域的数据格式传输协议 8、浏览器同源策略限制不允许跨域。 非跨域是指： 相同的域名、相同的协议、相同的端口。实现跨域的方式：（1）所有含有src属性的标签都不受同源策略限制，比如img，script，iframe，因此可以使用JSONP的方式，即客户端传递一个callback，服务端用callback包裹json数据，返回js片段，这样客户端就可以随意使用json数据，实现跨域了。比如统计点击率时经常用img标签。（jsonp的形式只支持get请求，不支持post请求。）（2）基于jquery的跨域，方式见下（9） (3) 利用document.domain进行跨域，document.domain可以进行赋值，但只可以设置为当前的域名或者基础域名。因此对于同一个基础域名的相同协议相同端口的跨域请求，可以通过设置document.domain来实现跨域。（4）window.postMessage()（5）cors：跨域资源共享是w3c的一个规范，这个主要在服务器的实现，前端发送请求没有区别。这和jsonp的区别是jsonp只支持get，cors可以支持post。 9、用jquery实现跨域的方式（1）直接将dataType设置为jsonp/当前网址是localhost:3000/js代码123456789101112131415161718192021222324252627282930$.ajax(&#123;type:\"get\",url:\"http://localhost:3000/showAll\",/*url写异域的请求地址*/dataType:\"jsonp\",/*加上datatype*/Jsonp: ‘cb', // 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)jsonpCallback:”success\",/*设置一个回调函数，名字随便取，和下面的函数里的名字相同就行*/success:function(data)&#123; console.log(data)&#125;&#125;);/*而在异域服务器上，*/app.jsapp.get('/showAll',students.showAll);/*这和不跨域的写法相同*//*在异域服务器的showAll函数里，*/var db = require(\"./database\");exports.showAll = function(req,res)&#123;/**设置响应头允许ajax跨域访问**/res.setHeader(\"Access-Control-Allow-Origin\",\"*\");/*星号表示所有的异域请求都可以接受，*/res.setHeader(\"Access-Control-Allow-Methods\",\"GET,POST\");var con = db.getCon();con.query(\"select * from t_students\",function(error,rows)&#123;if(error)&#123;console.log(\"数据库出错：\"+error);&#125;else&#123;/*注意这里，返回的就是jsonP的回调函数名+数据了*/res.send(\"cb(\"+JSON.stringify(r)+\")\");&#125;&#125;);&#125; （2）直接调用$.getJson进行跨域请求数据，其内部原理是判断是否跨域、如果非跨域，直接用ajax方式发送请求，否则用script标签的方式123jQuery.getJSON(url,data,success(data,status,function(data)&#123; Console.log(data)&#125;)) // url是可以非同源的Url，data为一起传递到服务器的数据。10、xss和csrf的区别（1）xss通过输入框或者textare等，往页面上注入一段js，csrf是伪装成当前登录用户发送请求，甚至更改当前用户的信息。（2）csrf的一种实现方式是xss，csrf注重结果。（3）xss避免的一种方式是将html标签进行过滤或者对内容进行encode，另外cookie信息不要放用户名和密码，必要时需要加md5加密，csrf的方式是前后端交互加令牌。11、cookie &amp; session（1）cookie不设置过期时间则保存在内存中，否则保存在硬盘中，下次打开会话，还能读取。cookie可以设置path和domain，且具有不可跨域性。（2）cookie是保存在浏览器上，session是保存在服务器中，因此cookie不是很安全，别人可以分析并且伪装。（3）cookie的value最大为4M，有些浏览器有限制每个站最多设置20个cookie。（4）session会占用服务器资源。12： ajax防止重复发送请求（1）点击后disable掉button（2）发送此请求时，abort掉上一个请求13：xhr（ajax）和fetch的区别（1）ajax为xhr，有abort状态(因为ajax是一个xmlhttpRequest，有个表示状态的readystatus，abort会将此值置为0，readystatus小于3，接收到的responseText未空)，fetch是基于promise实现的，只有resolve和reject状态，因而fetch没有abort状态。（2）fetch发送请求是不带cookie的，只有通过fetch（url, {credentials: ‘inlucde’ }）来加上（3）服务器返回400以及500状态是，fetch并不能reject，只有网络请求失败时会。14、ajax的readystatux状态（1） 0: 未初始化或者被abort到初始状态（2）1：已经初始化正在send请求（3）2： send已经完成（4）3： 已经解析了部分返回内容，未解析完（5）4： 相应内容已经解析完成15、函数防抖和节流（1） 防抖： 一段时间内，没有执行该函数，则一定时间后执行该函数，如果再次触发了事件，则从0开始计数，到达一定时间后再执行事件。123456789101112131415function debounce(fn, wait) &#123; var timer = null; return function() &#123; var context = this; var args = arguments; if( timer != null) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125;function handle() &#123; Console.log(‘handle')&#125;window.addEventListener(’scroll’, debounce(handle, 1000)) （2）节流：持续触发事件，保证一段时间内，调用一次当前函数。( 且能保证一段时间内至少执行一次)12345678910111213141516function throttle(fn, wait) &#123; var prev = Date.now(); return function() &#123; var now = Date.now(); var context = this; var args = arguments; If (prev - now &gt; delay) &#123; fn(context, args); Prev = Date.now(); &#125; &#125;&#125;function handle() &#123; console.log('handle')&#125;window.addEventListener('scroll', throttle(handle, 1000)) 16、vue和react的对比（1）vue和react都提倡组件化开发，都是数据驱动，都是通过props向组件传递参数，都有virtual dom（2）数据绑定： vue是双向数据绑定、react是单向（3）大规模协作的项目用react方便，小的项目用vue方便（2）开发风格：react用的是jsx，vue推荐使用的是 js css都在一个文件17、 gulp 和 webpack的区别18、原型和原型链（1）每个对象都有 proto 属性， 但只有函数对象才有 prototype属性（2）对象的proto属性指向他的构造函数 person1.proto = Person.prototype Person.proto = Function.prototype Person.prototype.proto = Object.prototype19、img的加载 - 懒加载（1）用img的src进行加载或者用css中background加载（2）重要的信息比如logo适合用img标签，如果图片特别大，建议用css中的background，这样不会影响整体框架在加载（3）动态的设置img的src信息即可20、函数闭包（1）闭包的例子：oldLog还保持旧值，而getLogNumber用新的值的原因可以从类定义，每个函数方法保存是单独的一份这点来区分。123456789101112131415161718var gLogNumber, gIncreaseNumber, gSetNumber;function setupSomeGlobals() &#123; // 局部变量num最后会保存在闭包中 var num = 42; // 将一些对于函数的引用存储为全局变量 gLogNumber = function() &#123; console.log(num); &#125; gIncreaseNumber = function() &#123; num++; &#125; gSetNumber = function(x) &#123; num = x; &#125;&#125;setupSomeGlobals();gIncreaseNumber();gLogNumber(); // 43gSetNumber(5);gLogNumber(); // 5var oldLog = gLogNumber;setupSomeGlobals();gLogNumber(); // 42oldLog() // 5 （2）下例中result是闭包变量，i最后值为3，list[3]是undefined12345678910111213141516function buildList(list) &#123; var result = []; for (var i = 0; i &lt; list.length; i++) &#123; var item = 'item' + i; result.push( function() &#123;console.log(item + ' ' + list[i])&#125; ); &#125; return result;&#125;function testList() &#123; var fnlist = buildList([1,2,3]); // 使用j是为了防止搞混---可以使用i for (var j = 0; j &lt; fnlist.length; j++) &#123; fnlist[j](); &#125;&#125; testList() //输出 \"item2 undefined\" 3 次 (3) 总结 函数内使用了关键字function就创建了一个闭包 闭包相当于一个副本，当函数退出时，所有的局部变量保存在其中 闭包函数每次被调用，都会被创建一份新的局部变量存储。21、JS中的this（1）在普通函数中，非严格模式下，this指向window，否则指向undefined；（2）作为构造函数中的this指向实例对象（3）call和apply可以改变this中的指向（4）箭头函数在执行前已经定死了this的指向22、常见的几类前端安全性问题： 老生常谈的XSS（cross site script） 处理方式： 对输入(和URL参数)进行过滤，对输出进行编码。对cookie中的关键信息设置httponly属性，防止被js读取。 警惕iframe带来的风险：防止自己的网页被iframe（1）直接判断当前网页的host是否和window.top的host是否相同(2)后台配置：header(‘X-Frame-Options:Deny’); iframe别人的网页时： 需要iframe设置sandbox属性，禁止iframe脚本、ajax请求、form表单、限制origin等 别被点击劫持了（clickjacking）利用iframe先响应click事件，防御策略是后台配置：header(‘X-Frame-Options:Deny’); 错误的内容推断 (比如：上传的图片是用js片段文件) 防火防盗防猪队友：不安全的第三方依赖包（第三方插件本身存在漏洞） 用了HTTPS也可能掉坑里，比如用户直接输入域名，未指定为https方式，会被拦截者获取并模拟服务器与前端交互，处理方式是强制前端用https进行通信 本地存储数据泄露：本地存储不放敏感信息，只放一些公共信息 缺失静态资源完整性校验：从cdn中获取的js是被拦截处理过的，导致系统不能正常运行。处理方式有：对引用的script或者css加签名，浏览器拿到资源后，首先进行内容hash，值相同才会进行下一步处理，否则不执行。（ Subresource Integrity | 内容安全策略中添加所有的 Content-Security-Policy: require-sri-for script;）23：pwa 离线缓存（1）相当于在浏览器和服务器之间加了一层service worker， 用来控制离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。并且还可以生成一个原生的操作图标。但这个强制使用https，且浏览器兼容差。24:Post请求数据的格式：（1）默认：application/x-www-form-urlencoded（2）上传图片： multipart/form-data（3）application/json;charset=utf-8（4）xml25: 硬件加速：将渲染的过程交给GPU进行处理，提高渲染性能。26: let const var区别var支持预定义 以及重复定义 其他二者不可let有了块级作用域const变量不可以改 不可以不赋值","categories":[],"tags":[{"name":"react, dom diff","slug":"react-dom-diff","permalink":"https://qiongqiongwoo.github.io/blog/tags/react-dom-diff/"}]},{"title":"React diff以及代码实现","slug":"Reactdiff以及代码实现","date":"2018-12-21T09:39:15.000Z","updated":"2019-01-04T09:58:21.000Z","comments":true,"path":"2018/12/21/Reactdiff以及代码实现/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/21/Reactdiff以及代码实现/","excerpt":"","text":"因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的。这样就需要每次获取dom的diff。react diff（1）diff 流程（2）tree diff: 假设： web ui 中 dom节点跨层级移动的操作很少，可以忽略不计。 优化：两棵树只比较同层节点是否相等，如果不等，直接删除，否则新建。 缺点： 如果出现跨层操作，比如将A整个移动到D下，整个处理过程为：create A -&gt; create B -&gt; create C -&gt; delete A， 效率很低。 指导原则： 不要使用dom节点的跨层级操作，可以用dom的显示和隐藏进行控制。（2）component diff假设：相同类的两个组件拥有相同的结构，不同类的两个组件的结构不同。优化：相同类的两个组件按照virtual dom的方式继续进行比较，不同类的两个组件直接替换，不进行比较，相同类的两个组件可以通过shouldComponentUpdate来进行比较。缺点： 两个component结构相似单直接导致替换，但实际开发中情况很少。指导原则：定义组件的shouldComponentUpdate （3）element diff假设：同一层的一组节点可以通过定个唯一的key来进行区分优化：同一层的一组节点定义唯一的key，通过key进行比较和重建重建方式: 遍历新的节点顺序，如果当前的节点在旧的结构中的挂载Index &lt; 当前的遍历Index值，则对当前节点进行移动，否则不移动。缺点：如果将最后的一个节点移动到了行首，会导致整个链上的节点的移动，效率很低。指导原则：不要讲最后一个节点移动到行首。diff的差异比较过程如下：首先对新集合的节点进行循环遍历，for (name in nextChildren)，通过唯一 key 可以判断新老集合中是否存在相同的节点，if (prevChild === nextChild)，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与 lastIndex 进行比较，if (child._mountIndex &lt; lastIndex)，则进行节点移动操作，否则不执行该操作。这是一种顺序优化手段，lastIndex 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置），如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点比 lastIndex 小时，才需要进行移动操作。以上图为例，可以更为清晰直观的描述 diff 的差异对比过程： 从新集合中取得 B，判断老集合中存在相同节点 B，通过对比节点位置判断是否进行移动操作，B 在老集合中的位置 B._mountIndex = 1，此时 lastIndex = 0，不满足 child._mountIndex &lt; lastIndex 的条件，因此不对 B 进行移动操作；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，其中 prevChild._mountIndex 表示 B 在老集合中的位置，则 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置prevChild._mountIndex = nextIndex，此时新集合中 B._mountIndex = 0，nextIndex++ 进入下一个节点的判断。 从新集合中取得 A，判断老集合中存在相同节点 A，通过对比节点位置判断是否进行移动操作，A 在老集合中的位置 A._mountIndex = 0，此时 lastIndex = 1，满足 child._mountIndex &lt; lastIndex的条件，因此对 A 进行移动操作enqueueMove(this, child._mountIndex, toIndex)，其中 toIndex 其实就是 nextIndex，表示 A 需要移动到的位置；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 1，并将 A 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中A._mountIndex = 1，nextIndex++ 进入下一个节点的判断。 从新集合中取得 D，判断老集合中存在相同节点 D，通过对比节点位置判断是否进行移动操作，D 在老集合中的位置 D._mountIndex = 3，此时 lastIndex = 1，不满足 child._mountIndex &lt; lastIndex的条件，因此不对 D 进行移动操作；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 3，并将 D 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中D._mountIndex = 2，nextIndex++ 进入下一个节点的判断。 从新集合中取得 C，判断老集合中存在相同节点 C，通过对比节点位置判断是否进行移动操作，C 在老集合中的位置 C._mountIndex = 2，此时 lastIndex = 3，满足 child._mountIndex &lt; lastIndex 的条件，因此对 C 进行移动操作 enqueueMove(this, child._mountIndex, toIndex)；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 3，并将 C 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中 C._mountIndex = 3，nextIndex++ 进入下一个节点的判断，由于 C 已经是最后一个节点，因此 diff 到此完成。以上主要分析新老集合中存在相同节点但位置不同时，对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？以下图为例： 从新集合中取得 B，判断老集合中存在相同节点 B，由于 B 在老集合中的位置 B._mountIndex = 1，此时lastIndex = 0，因此不对 B 进行移动操作；更新 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置B._mountIndex = 0，nextIndex++进入下一个节点的判断。 从新集合中取得 E，判断老集合中不存在相同节点 E，则创建新节点 E；更新 lastIndex ＝ 1，并将 E 的位置更新为新集合中的位置，nextIndex++进入下一个节点的判断。 从新集合中取得 C，判断老集合中存在相同节点 C，由于 C 在老集合中的位置C._mountIndex = 2，lastIndex = 1，此时 C._mountIndex &gt; lastIndex，因此不对 C 进行移动操作；更新 lastIndex ＝ 2，并将 C 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。 从新集合中取得 A，判断老集合中存在相同节点 A，由于 A 在老集合中的位置A._mountIndex = 0，lastIndex = 2，此时 A._mountIndex &lt; lastIndex，因此对 A 进行移动操作；更新 lastIndex ＝ 2，并将 A 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。 当完成新集合中所有节点 diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 D，因此删除节点 D，到此 diff 全部完成。react diff代码实现解析（1）component的mountComponent完成组件的第一次render，receiveComponent完成组件的更新处理。组件的setState的实现即是调用receiveComponent的处理。（2）receiveComponent的处理流程: receiveComponent = function(nextElement, newState) 更新当前组件的currentElement（保存组件的render类型，p还是div，还是自定义的element类型1或者自定义的element2）this._currentElement = nextElement || this._currentElement (组件的render类型对应diff原则中的不同类型的组件重新渲染原则) newState = 旧的state merge newState 如果组件有自定义的shouldComponentUpdate方法，如果此方法返回为false，不再进行更新直接返回。 如果组件有定义componentWillUpdate（更新前的处理方法），调用此方法，表示开始更新。 重新执行组件的render方法，拿到新的element（nextRenderedElemnt）（此过程在内存中进行，而非真正的渲染） 调用全局的shouldUpdateComponent(prevRenderedElement, nextRenderedElement)方法，此方法的输入为两个element，如果element类型为基础类型，直接返回false，否则递归调用子元素的此方法 shouldUpdateComponent(prevRenderedElement, nextRenderedElement)返回为false的情况下（为基础节点或者两个非基础节点，但类型不同），则直接将整个dom节点进行替换，并更新到dom中。（3）shouldUpdateComponent(prevRenderedElement, nextRenderedElement) 为整个diff实现的主要方法，流程如下：（判断：当前节点是进行全局替换还是进行局部比较替换）（生成新的element以及element进行比较的过程是在内存中进行，而非替换真正的dom，所以效率是极高的） 判断prevElement是否为基础类型，如果是基础类型，直接返回nextElement是否为基础类型，如果是基础类型，调用prevElement的更新操作，否则执行render以及整个替换操作 prevElement不是基础类型，并且nextElement也不是基础类型，并且type类型相同且key相同，执行子节点的update操作，否则直接进行整个节点的替换操作（4）receiveComponent逻辑 文本类型：receiveComponent = function (newTextString) { $(‘[data-reactid=“‘+this._rootNodeId+’”]’).html(newTextString); } 基本类型的更新： 首先更新当前节点的props属性，然后递归调用，更新每个子节点（updateDOMChildren）（子节点或者为文本类型或者为基本类型，如果子节点为自定义类型如何处理？）属性的更新过程： 如果在新的属性中不包含的属性，删掉，如果是新添加的属性，添加，否则进行值替换。这些操作为真正的dom操作，不同类型的属性的更新和生效方式也不同，需要特别处理。 自定义类型：(5) updateDOMChildren的处理逻辑（全局的diffQueue队列，diff方法，以及获取到diffQueue后的patch更新操作），所以关键是diff和patch方法。diff操作对应diff原则中的element diff diff方法处理流程： diff(diffQueue, nextChildrenElements) nextChildrenElements利用key或者id处理成map形式,方便下面的diff处理（flatternChildren） 调用gennerateComponentChildren生成新的nextChildren，此方法中根据新旧child的不同调用上面提到的shouldUpdateReactComponent方法做到最小粒度度更新 对新旧children进行比较，标记上三种状态： move_existing(新的componet在旧的中存在，只移动)，insert_makeup(新的不存在或者新旧类型不同，需要新建并且插入)， remove_node(旧的组件在新的中不存在或者类型发生了变化，需要删除) 得到diffQueue后执行patch操作流程 第一遍遍历queue删除所有标记为要删除的节点 第二遍处理插入和要修改的节点 最终迷你版本的react js实现如下： (这个已经不记得转载的哪里的了)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572//component类，用来表示文本在渲染，更新，删除时应该做些什么事情function ReactDOMTextComponent(text) &#123; //存下当前的字符串 this._currentElement = '' + text; //用来标识当前component this._rootNodeID = null;&#125;//component渲染时生成的dom结构ReactDOMTextComponent.prototype.mountComponent = function(rootID) &#123; this._rootNodeID = rootID; return '&lt;span data-reactid=\"' + rootID + '\"&gt;' + this._currentElement + '&lt;/span&gt;';&#125;ReactDOMTextComponent.prototype.receiveComponent = function(nextText) &#123; var nextStringText = '' + nextText; //跟以前保存的字符串比较 if (nextStringText !== this._currentElement) &#123; this._currentElement = nextStringText; //替换整个节点 $('[data-reactid=\"' + this._rootNodeID + '\"]').html(this._currentElement); &#125;&#125;//component类，用来表示文本在渲染，更新，删除时应该做些什么事情function ReactDOMComponent(element) &#123; //存下当前的element对象引用 this._currentElement = element; this._rootNodeID = null;&#125;//component渲染时生成的dom结构ReactDOMComponent.prototype.mountComponent = function(rootID) &#123; //赋值标识 this._rootNodeID = rootID; var props = this._currentElement.props; var tagOpen = '&lt;' + this._currentElement.type; var tagClose = '&lt;/' + this._currentElement.type + '&gt;'; //加上reactid标识 tagOpen += ' data-reactid=' + this._rootNodeID; //拼凑出属性 for (var propKey in props) &#123; //这里要做一下事件的监听，就是从属性props里面解析拿出on开头的事件属性的对应事件监听 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //针对当前的节点添加事件代理,以_rootNodeID为命名空间 $(document).delegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType + '.' + this._rootNodeID, props[propKey]); &#125; //对于children属性以及事件监听的属性不需要进行字符串拼接 //事件会代理到全局。这边不能拼到dom上不然会产生原生的事件监听 if (props[propKey] &amp;&amp; propKey != 'children' &amp;&amp; !/^on[A-Za-z]/.test(propKey)) &#123; tagOpen += ' ' + propKey + '=' + props[propKey]; &#125; &#125; //获取子节点渲染出的内容 var content = ''; var children = props.children || []; var childrenInstances = []; //用于保存所有的子节点的componet实例，以后会用到 var that = this; $.each(children, function(key, child) &#123; //这里再次调用了instantiateReactComponent实例化子节点component类，拼接好返回 var childComponentInstance = instantiateReactComponent(child); childComponentInstance._mountIndex = key; childrenInstances.push(childComponentInstance); //子节点的rootId是父节点的rootId加上新的key也就是顺序的值拼成的新值 var curRootId = that._rootNodeID + '.' + key; //得到子节点的渲染内容 var childMarkup = childComponentInstance.mountComponent(curRootId); //拼接在一起 content += ' ' + childMarkup; &#125;) //留给以后更新时用的这边先不用管 this._renderedChildren = childrenInstances; //拼出整个html内容 return tagOpen + '&gt;' + content + tagClose;&#125;ReactDOMComponent.prototype.receiveComponent = function(nextElement) &#123; var lastProps = this._currentElement.props; var nextProps = nextElement.props; this._currentElement = nextElement; //需要单独的更新属性 this._updateDOMProperties(lastProps, nextProps); //再更新子节点 this._updateDOMChildren(nextElement.props.children);&#125;ReactDOMComponent.prototype._updateDOMProperties = function(lastProps, nextProps) &#123; var propKey; //遍历，当一个老的属性不在新的属性集合里时，需要删除掉。 for (propKey in lastProps) &#123; //新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除 if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) &#123; continue; &#125; //对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //针对当前的节点取消事件代理 $(document).undelegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType, lastProps[propKey]); continue; &#125; //从dom上删除不需要的属性 $('[data-reactid=\"' + this._rootNodeID + '\"]').removeAttr(propKey) &#125; //对于新的属性，需要写到dom节点上 for (propKey in nextProps) &#123; //对于事件监听的属性我们需要特殊处理 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //以前如果已经有，说明有了监听，需要先去掉 lastProps[propKey] &amp;&amp; $(document).undelegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType, lastProps[propKey]); //针对当前的节点添加事件代理,以_rootNodeID为命名空间 $(document).delegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType + '.' + this._rootNodeID, nextProps[propKey]); continue; &#125; if (propKey == 'children') continue; //添加新的属性，或者是更新老的同名属性 $('[data-reactid=\"' + this._rootNodeID + '\"]').prop(propKey, nextProps[propKey]) &#125;&#125;//全局的更新深度标识var updateDepth = 0;//全局的更新队列，所有的差异都存在这里var diffQueue = [];ReactDOMComponent.prototype._updateDOMChildren = function(nextChildrenElements) &#123; updateDepth++ //_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。 this._diff(diffQueue, nextChildrenElements); updateDepth-- if (updateDepth == 0) &#123; //在需要的时候调用patch，执行具体的dom操作 this._patch(diffQueue); diffQueue = []; &#125;&#125;//差异更新的几种类型var UPATE_TYPES = &#123; MOVE_EXISTING: 1, REMOVE_NODE: 2, INSERT_MARKUP: 3&#125;//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识function flattenChildren(componentChildren) &#123; var child; var name; var childrenMap = &#123;&#125;; for (var i = 0; i &lt; componentChildren.length; i++) &#123; child = componentChildren[i]; name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(36); childrenMap[name] = child; &#125; return childrenMap;&#125;//主要用来生成子节点elements的component集合//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。//如果是新的节点，就会重新生成一个新的componentInstance，function generateComponentChildren(prevChildren, nextChildrenElements) &#123; var nextChildren = &#123;&#125;; nextChildrenElements = nextChildrenElements || []; $.each(nextChildrenElements, function(index, element) &#123; var name = element.key ? element.key : index; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var prevElement = prevChild &amp;&amp; prevChild._currentElement; var nextElement = element; //调用_shouldUpdateReactComponent判断是否是更新 if (_shouldUpdateReactComponent(prevElement, nextElement)) &#123; //更新的话直接递归调用子节点的receiveComponent就好了 prevChild.receiveComponent(nextElement); //然后继续使用老的component nextChildren[name] = prevChild; &#125; else &#123; //对于没有老的，那就重新新增一个，重新生成一个component var nextChildInstance = instantiateReactComponent(nextElement, null); //使用新的component nextChildren[name] = nextChildInstance; &#125; &#125;) return nextChildren;&#125;//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。ReactDOMComponent.prototype._diff = function(diffQueue, nextChildrenElements) &#123; var self = this; //拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的，记不得的可以翻上面 //_renderedChildren 本来是数组，我们搞成map var prevChildren = flattenChildren(self._renderedChildren); //生成新的子节点的component对象集合，这里注意，会复用老的component对象 var nextChildren = generateComponentChildren(prevChildren, nextChildrenElements); //重新赋值_renderedChildren，使用最新的。 self._renderedChildren = [] $.each(nextChildren, function(key, instance) &#123; self._renderedChildren.push(instance); &#125;) /**注意新增代码**/ var lastIndex = 0; //代表访问的最后一次的老的集合的位置 var nextIndex = 0; //代表到达的新的节点的index //通过对比两个集合的差异，组装差异节点添加到队列中 for (name in nextChildren) &#123; if (!nextChildren.hasOwnProperty(name)) &#123; continue; &#125; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var nextChild = nextChildren[name]; //相同的话，说明是使用的同一个component,所以我们需要做移动的操作 if (prevChild === nextChild) &#123; //添加差异对象，类型：MOVE_EXISTING /**注意新增代码**/ prevChild._mountIndex &lt; lastIndex &amp;&amp; diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.MOVE_EXISTING, fromIndex: prevChild._mountIndex, toIndex: nextIndex &#125;) /**注意新增代码**/ lastIndex = Math.max(prevChild._mountIndex, lastIndex); &#125; else &#123; //如果不相同，说明是新增加的节点 //但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。 if (prevChild) &#123; //添加差异对象，类型：REMOVE_NODE diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.REMOVE_NODE, fromIndex: prevChild._mountIndex, toIndex: null &#125;) //如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空 if (prevChild._rootNodeID) &#123; $(document).undelegate('.' + prevChild._rootNodeID); &#125; /**注意新增代码**/ lastIndex = Math.max(prevChild._mountIndex, lastIndex); &#125; //新增加的节点，也组装差异对象放到队列里 //添加差异对象，类型：INSERT_MARKUP diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.INSERT_MARKUP, fromIndex: null, toIndex: nextIndex, markup: nextChild.mountComponent(self._rootNodeID + '.' + name) //新增的节点，多一个此属性，表示新节点的dom内容 &#125;) &#125; //更新mount的index nextChild._mountIndex = nextIndex; nextIndex++; &#125; //对于老的节点里有，新的节点里没有的那些，也全都删除掉 for (name in prevChildren) &#123; if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123; //添加差异对象，类型：REMOVE_NODE diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.REMOVE_NODE, fromIndex: prevChildren[name]._mountIndex, toIndex: null &#125;) //如果以前已经渲染过了，记得先去掉以前所有的事件监听 if (prevChildren[name]._rootNodeID) &#123; $(document).undelegate('.' + prevChildren[name]._rootNodeID); &#125; &#125; &#125;&#125;//用于将childNode插入到指定位置function insertChildAt(parentNode, childNode, index) &#123; var beforeChild = parentNode.children().get(index); beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);&#125;ReactDOMComponent.prototype._patch = function(updates) &#123; var update; var initialChildren = &#123;&#125;; var deleteChildren = []; for (var i = 0; i &lt; updates.length; i++) &#123; update = updates[i]; if (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) &#123; var updatedIndex = update.fromIndex; var updatedChild = $(update.parentNode.children().get(updatedIndex)); var parentID = update.parentID; //所有需要更新的节点都保存下来，方便后面使用 initialChildren[parentID] = initialChildren[parentID] || []; //使用parentID作为简易命名空间 initialChildren[parentID][updatedIndex] = updatedChild; //所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可 deleteChildren.push(updatedChild) &#125; &#125; //删除所有需要先删除的 $.each(deleteChildren, function(index, child) &#123; $(child).remove(); &#125;) //再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入 for (var k = 0; k &lt; updates.length; k++) &#123; update = updates[k]; switch (update.type) &#123; case UPATE_TYPES.INSERT_MARKUP: insertChildAt(update.parentNode, $(update.markup), update.toIndex); break; case UPATE_TYPES.MOVE_EXISTING: insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex); break; case UPATE_TYPES.REMOVE_NODE: // 什么都不需要做，因为上面已经帮忙删除掉了 break; &#125; &#125;&#125;function ReactCompositeComponent(element) &#123; //存放元素element对象 this._currentElement = element; //存放唯一标识 this._rootNodeID = null; //存放对应的ReactClass的实例 this._instance = null;&#125;//用于返回当前自定义元素渲染时应该返回的内容ReactCompositeComponent.prototype.mountComponent = function(rootID) &#123; this._rootNodeID = rootID; //拿到当前元素对应的属性值 var publicProps = this._currentElement.props; //拿到对应的ReactClass var ReactClass = this._currentElement.type; // Initialize the public class var inst = new ReactClass(publicProps); this._instance = inst; //保留对当前comonent的引用，下面更新会用到 inst._reactInternalInstance = this; if (inst.componentWillMount) &#123; inst.componentWillMount(); //这里在原始的reactjs其实还有一层处理，就是 componentWillMount调用setstate，不会触发rerender而是自动提前合并，这里为了保持简单，就略去了 &#125; //调用ReactClass的实例的render方法,返回一个element或者一个文本节点 var renderedElement = this._instance.render(); //得到renderedElement对应的component类实例 var renderedComponentInstance = instantiateReactComponent(renderedElement); this._renderedComponent = renderedComponentInstance; //存起来留作后用 //拿到渲染之后的字符串内容，将当前的_rootNodeID传给render出的节点 var renderedMarkup = renderedComponentInstance.mountComponent(this._rootNodeID); //之前我们在React.render方法最后触发了mountReady事件，所以这里可以监听，在渲染完成后会触发。 $(document).on('mountReady', function() &#123; //调用inst.componentDidMount inst.componentDidMount &amp;&amp; inst.componentDidMount(); &#125;); return renderedMarkup;&#125;ReactCompositeComponent.prototype.receiveComponent = function(nextElement, newState) &#123; //如果接受了新的，就使用最新的element this._currentElement = nextElement || this._currentElement var inst = this._instance; //合并state var nextState = $.extend(inst.state, newState); var nextProps = this._currentElement.props; //改写state inst.state = nextState; //如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。 if (inst.shouldComponentUpdate &amp;&amp; (inst.shouldComponentUpdate(nextProps, nextState) === false)) return; //生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。 if (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState); var prevComponentInstance = this._renderedComponent; var prevRenderedElement = prevComponentInstance._currentElement; //重新执行render拿到对应的新element; var nextRenderedElement = this._instance.render(); //判断是需要更新还是直接就重新渲染 //注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法 if (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123; //如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。 prevComponentInstance.receiveComponent(nextRenderedElement); //调用componentDidUpdate表示更新完成了 inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); &#125; else &#123; //如果发现完全是不同的两种element，那就干脆重新渲染了 var thisID = this._rootNodeID; //重新new一个对应的component， this._renderedComponent = this._instantiateReactComponent(nextRenderedElement); //重新生成对应的元素内容 var nextMarkup = _renderedComponent.mountComponent(thisID); //替换整个节点 $('[data-reactid=\"' + this._rootNodeID + '\"]').replaceWith(nextMarkup); &#125;&#125;//用来判定两个element需不需要更新//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。var _shouldUpdateReactComponent = function(prevElement, nextElement) &#123; if (prevElement != null &amp;&amp; nextElement != null) &#123; var prevType = typeof prevElement; var nextType = typeof nextElement; if (prevType === 'string' || prevType === 'number') &#123; return nextType === 'string' || nextType === 'number'; &#125; else &#123; return nextType === 'object' &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key; &#125; &#125; return false;&#125;function instantiateReactComponent(node) &#123; //文本节点的情况 if (typeof node === 'string' || typeof node === 'number') &#123; return new ReactDOMTextComponent(node); &#125; //浏览器默认节点的情况 if (typeof node === 'object' &amp;&amp; typeof node.type === 'string') &#123; //注意这里，使用了一种新的component return new ReactDOMComponent(node); &#125; //自定义的元素节点 if (typeof node === 'object' &amp;&amp; typeof node.type === 'function') &#123; //注意这里，使用新的component,专门针对自定义元素 return new ReactCompositeComponent(node); &#125;&#125;//ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props//比如对于div这样的节点type就是div，props就是那些propibutes//另外这里的key,可以用来标识这个element，用于优化以后的更新，这里可以先不管，知道有这么个东西就好了function ReactElement(type,key,props)&#123; this.type = type; this.key = key; this.props = props;&#125;//定义ReactClass类,所有自定义的超级父类var ReactClass = function() &#123;&#125; //留给子类去继承覆盖ReactClass.prototype.render = function() &#123;&#125;//setStateReactClass.prototype.setState = function(newState) &#123; //还记得我们在ReactCompositeComponent里面mount的时候 做了赋值 //所以这里可以拿到 对应的ReactCompositeComponent的实例_reactInternalInstance this._reactInternalInstance.receiveComponent(null, newState);&#125;React = &#123; nextReactRootIndex: 0, createClass: function(spec) &#123; //生成一个子类 var Constructor = function(props) &#123; this.props = props; this.state = this.getInitialState ? this.getInitialState() : null; &#125; //原型继承，继承超级父类 Constructor.prototype = new ReactClass(); Constructor.prototype.constructor = Constructor; //混入spec到原型 $.extend(Constructor.prototype, spec); return Constructor; &#125;, createElement: function(type, config, children) &#123; var props = &#123;&#125;,propName; config = config || &#123;&#125; //看有没有key，用来标识element的类型，方便以后高效的更新，这里可以先不管 var key = config.key || null; //复制config里的内容到props for (propName in config) &#123; if (config.hasOwnProperty(propName) &amp;&amp; propName !== 'key') &#123; props[propName] = config[propName]; &#125; &#125; //处理children,全部挂载到props的children属性上 //支持两种写法，如果只有一个参数，直接赋值给children，否则做合并处理 var childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = $.isArray(children) ? children : [children] ; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; props.children = childArray; &#125; return new ReactElement(type, key,props); &#125;, render: function(element, container) &#123; var componentInstance = instantiateReactComponent(element); var markup = componentInstance.mountComponent(React.nextReactRootIndex++); $(container).html(markup); //触发完成mount的事件 $(document).trigger('mountReady'); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"./react-little.js\"&gt;&lt;/script&gt;&lt;style type=\"text/css\"&gt; #container&#123; width: 500px; background-color: #fafafa; min-height: 200px; margin: 100px auto; text-align: center; padding: 20px; &#125; #container p&#123; display: inline-block; border: 1px solid #999; padding: 5px 5px; cursor: pointer; &#125; #container input&#123; width: 200px; border: 1px solid #999; padding: 6px; vertical-align: 1px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var TodoList = React.createClass(&#123; getInitialState: function() &#123; return &#123;items: []&#125;; &#125;, add:function()&#123; var nextItems = this.state.items.concat([this.state.text]); this.setState(&#123;items: nextItems, text: ''&#125;); &#125;, onChange: function(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125;, render: function() &#123; var createItem = function(itemText) &#123; return React.createElement(\"div\", null, itemText); &#125;; var lists = this.state.items.map(createItem); var input = React.createElement(\"input\", &#123;onkeyup: this.onChange.bind(this),value: this.state.text&#125;); var button = React.createElement(\"p\", &#123;onclick: this.add.bind(this)&#125;, 'Add#' + (this.state.items.length + 1)) var children = [input,button].concat(lists) return React.createElement(\"div\", null,children); &#125;&#125;);React.render(React.createElement(TodoList), document.getElementById(\"container\"));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"react, dom diff","slug":"react-dom-diff","permalink":"https://qiongqiongwoo.github.io/blog/tags/react-dom-diff/"}]},{"title":"浏览器渲染","slug":"浏览器渲染","date":"2018-12-14T06:21:42.000Z","updated":"2019-01-04T09:06:41.000Z","comments":true,"path":"2018/12/14/浏览器渲染/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/14/浏览器渲染/","excerpt":"","text":"1、浏览器是多进程的比如chrome browser进程：与用户交互、浏览器的前进后退、各个tab页面的管理等 GPU进程：3D页面绘制等 浏览器渲染进程（Render进程，其内部是多线程的）每个tab对应一个，相互独立。2、如上所述Render进程是多线程的 JS引擎线程—– 主线程（JS内核负责解析和运行代码，一个Render进程只有一个JS引擎线程） GUI渲染线程：负责渲染浏览器界面，当界面需要repaint或者reflow时就会执行。 事件触发线程：事件被触发时，将事件添加到事件处理队列等待JS引擎被执行。 定时触发线程：setTimeout、setInterval所在线程 异步请求线程：XMLHttpRequest在连接后通过浏览器开一个线程请求3、JS引擎和渲染引擎之间的关系 JS引擎线程和GUI渲染线程是互斥的，JS引擎执行时，GUI渲染线程会被挂起。 JS引擎花费时间过多时，会出现浏览器卡死的情况。 JS是单线程是指解释和执行JS的线程只有一个，即主线程、JS引擎线程。4、JS的运行机制如下 所有的同步任务都在主线程上执行，形成一个函数执行栈 主线程之外有个任务队列 一旦stack为空，主线程就去读取任务队列中的异步任务进行执行 主线程循环重复上面三个步骤 事件触发线程注册函数，当事件触发时，被推入event loop（消息队列的形式，消息队列中每一条信息都对应着一个事件） 主线程函数栈执行完后，循环从消息队列中取消息进行处理5、web worker &amp; share worker JS引擎向浏览器申请开一个子线程做一些耗时处理（此子线程不能操作dom，完全受JS引擎的控制） share worker是浏览器的多个tab共享的，web worker属于单独的一个tab6、宏任务（macro-task）和微任务(micro-task)的执行 宏任务： script\\setTimeout\\setTimeInterval\\setTimeImmediate\\ 微任务： promise、process.nextTick、mutationObserver 根据html standard，在每个macro-task执行完之后，UI都会重新渲染，如果再micro-task中完成数据的处理，则当前task执行完之后就可以得到最终的UI，但如果在一个新的task中进行执行，需要两次渲染才能得到最终的UI，这也是promise要好于setTimeOut的地方。12345678910111213setTimeout(function()&#123; console.log('定时器开始啦’) &#125;); new Promise(function(resolve)&#123; console.log('马上执行for循环啦’); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125; &#125;).then(function()&#123; console.log('执行then函数啦’) &#125;); console.log('代码执行结束’); // 浏览器的执行结果为 马上执行for循环啦 -&gt; 代码执行结束 -&gt; 执行then函数啦 -&gt; 定时器开始啦1.整体script作为第一个宏任务进入主线程，这是第一轮宏任务。2.遇到setTimeout，其回调函数被分发到宏任务Event Queue中，这是第二个宏任务。3.继续执行，打印【马上执行for循环啦】4.遇到promise.then()微任务，这是第一轮宏任务下的微任务，因为整体script是第一轮宏任务嘛5.继续执行，打印【代码执行结束】6.现在整体script作为第一轮宏任务，去检查这一轮下的微任务，发现有一个promise.then()，去执行它（至此现在第一轮宏任务，以及这一轮宏任务下的微任务都被执行过了）7.开始第二轮宏任务，发现宏任务队列里有一个setTimeout，执行它，就打印了【定时器开始啦】// 注意： node中的执行结果和上面是不同的7、浏览器渲染流程style Tree的结构 Dom树构建的过程包括符号化和构建树两个过程，符号化采用符号识别算法 DomContentLoaded仅当dom加载完成不包括样式表，onload事件是dom、样式、图片、脚本全都执行完毕了 从上图可以看到、Css的加载不会阻塞dom树的解析但会阻塞render树的渲染 Web模式是同步的，遇到script标签，会执行完js再进行后续的解析，遇到引用外部的script，同样会等到js下载完，这样会阻塞后续的资源下载，因此出现了预解析。 预解析分析引用的外部资源，同步进行下载以提高速度，但并不构建dom树。 渲染树和dom树不是一一对应的，不可见的dom元素不会插入到渲染树中，display为none的元素也不会插入。8、dom树的构建过程 二进制字节流 — -1—&gt; 字符流 —–2—-&gt; 词语 ——-3–&gt; 多个节点 -—-4——-&gt;Dom树 1是根据页面的编码格式， 2根据词法分析（基于状态机的符号识别算法） 4可以利用栈（所有的标签都是闭合的），3是存储类似于 在步骤3中会识别出全局的JavaScript代码，此时dom树尚未创建，因此不能访问dom。9、layout(reflow)和repaint，layout就是计算元素的大小位置等信息，确定每个元素在页面上的位置 Layout(reflow):表示元素的内容、结构、尺寸位置发生了变化，需要重新计算样式和渲染树 repaint:元素的背景色、边框文字颜色发生变化。 reflow的成本要高于repaint，应该尽量避免reflow，回流一定伴随着重绘，重绘却会单独出现10、引起layout（reflow）的情况 dom结构改变比如删除一个节点 render树变化，比如padding变化 窗口resize font字体大小发生变化 获取一些属性时会引发回流，比如： offset（height/width…）、scroll（height/width…）、client（height/width…）,width，height，getComputedStyle等12345678var s = document.body.style;s.padding = \"2px\"; // 回流+重绘s.border = \"1px solid red\"; // 再一次 回流+重绘s.color = \"blue\"; // 再一次重绘s.backgroundColor = \"#ccc\"; // 再一次 重绘s.fontSize = \"14px\"; // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode('abc!')); 11、reflow的优化方案 style的改变一次性改，比如通过class改变 避免循环添加dom，统一处理一次添加 将复杂的元素绝对或者固定定位，脱离文档流，减少回流代价12、防止浏览器卡死的方式 优化循环 12345678910111213function chunk(array, process, context) &#123; setTimeout(function inner() &#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0) &#123; setTimeout(inner, 100); &#125; &#125;, 100);&#125; // 此处递归操作直接用inner 而不是直接调用chunk的原因如下：Var chunkObj = chunkchunObj(array, process, context) // 可以正常执行chunk = function(array, process, context) &#123; console.log(‘fadfdasfds’)&#125;chunObj(array, process, context) // 不能正常执行，其内部的 chunk已经被新的定义替代 如果函数体内有不相干的、执行也没有先后的操作，则可以用chunk方式进行拆分或者直接交给浏览器去调度 1234567891011121314151617181920function doSomething()&#123; setTimeout（dosomething1, 0） setTimeout（dosomething2, 0）&#125;* 优化递归操作function fac(num) &#123; var tmp = &#123;&#125; return (function fn(n)&#123; var res; if (tmp[n])&#123; res= tmp[n]; console.log('match'+n) // 此处通过暂存数据，将减少递归层次， 这种优化牺牲了空间，还有一种方式是中间的结果不暂存， 利用迭代操作进行优化。 &#125; else &#123; if(n &lt;= 1) res = 1; else res = fn(n-2) + fn(n-1) &#125; tmp[n] = res; return res; &#125;)(num)&#125; 减少dom操作： 例如改变style的三个值不如通过设置一个class效率更高13、外链css的下载会阻塞JS的执行 1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;script&gt; function printH2() &#123; console.log('first script', document.querySelectorAll('h2')); &#125; printH2() setTimeout(printH2) // JS脚本之前如果没有css标签，这部分的执行是不会被阻塞的 &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/4.0.0-alpha.4/css/bootstrap.css\"&gt; &lt;h2&gt;World&lt;/h2&gt; &lt;script&gt; console.log('second script’); // 此处的执行会受到css的下载的影响 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 14、两个js的执行并非等到完全下载完1234&lt;body&gt;&lt;script src=\"1.js\"&gt;&lt;/script&gt; // 如果1下载5s， 2下载10s，1在5s后执行，2在10s后执行&lt;script src=\"2.js\"&gt;&lt;/script&gt; // 如果1下载10s， 2下载5s, 1在10s后执行，1执行完再执行2&lt;/body&gt; 15：渲染过程的一个例子（一下为firefox的例子）123456789&lt;doc&gt;&lt;title&gt;A few quotes&lt;/title&gt;&lt;para class=\"emph\"&gt; Franklin said that &lt;quote&gt;\"A penny saved is a penny earned.\"&lt;/quote&gt;&lt;/para&gt;&lt;para&gt; FDR said &lt;quote&gt;\"We have nothing to fear but &lt;span class=\"emph\"&gt;fear itself.&lt;/span&gt;\"&lt;/quote&gt;&lt;/para&gt;&lt;/doc&gt; css 规则如下：1234 /* rule 1 */ doc &#123; display: block; text-indent: 1em; &#125;/* rule 2 */ title &#123; display: block; font-size: 3em; &#125;/* rule 3 */ para &#123; display: block; &#125;/* rule 4 */ [class=\"emph\"] &#123; font-style: italic; &#125; 对应的dom树、css规则树以及style context tree分别为：(此段描述的未 attachment的过程：其实就是dom树上的每个节点，找到其对应的style的过程) css rule tree结构为（css rule tree是根据dom树构建出来的，所以4节点有两个 CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去 chrom中不存在规则树，他直接将节点的style存在了dom树的节点上 接下来开始计算CSS样式（每个dom节点的）—&gt;构建Render Tree -&gt; Layout(定位坐标和大小，换行、position, overflow, z-index等）—&gt;composition -&gt; paint","categories":[],"tags":[{"name":"浏览器渲染","slug":"浏览器渲染","permalink":"https://qiongqiongwoo.github.io/blog/tags/浏览器渲染/"}]},{"title":"整理的css知识","slug":"整理的css知识","date":"2018-12-14T05:01:21.000Z","updated":"2019-01-04T04:08:34.000Z","comments":true,"path":"2018/12/14/整理的css知识/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/14/整理的css知识/","excerpt":"","text":"css标准地址 https://www.w3.org/TR/CSS2/visuren.html#inline-formatting1、block、inline、inline-block每个页面元素都有一个display属性，每个元素的display属性都有一个默认值，比如div的display属性为block，span的display属性为inline，inline元素不会自动换行且没有宽和高、block元素有宽和高度，且会自动换行。常见的元素分类如下：（1）block元素：body form textarea h1 - h6 html table button p ul ol div（2）inline元素：title span a em b strong I map 等（3）inline-block元素：img input td select textarea label区别方式为：是否可以设置宽、高、margin、padding值、是否会换行。对inline元素这只padding-top padding-bottom margin-bottom margin-top不会对周边元素产生影响，会加大自身的范围。2、嵌套规则：（1）块状元素可以包含内联元素或者块元素，内连元素不可以包含块元素只包含内连元素123&lt;a href=\"#\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; — 正确&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; — 正确&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; — 正确 （2）h1- h6、p、 dt这几个块元素只能包含内联元素或者可变元素12&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; -- wrong&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; — wrong （3）特殊的li标签内可以出现div标签（4）块级元素可以与块级元素并列、内联元素可以和内联元素并列123&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; — right&lt;div&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; — right&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; -- wrong 3、inline元素改为block元素的方式（1）直接将display值设置为block/inline-block（2）直接将position设置为absolute或者fix4、inline-block元素出现缝隙的解决方式（1）两个inline-block元素之间不能出现换行、空格等（2）设置margin-right值为负值（3）将父元素的font-size、letter-spacing、word-spacing值5、block元素内的inline-block元素出现底部空白或者两个inline-block元素无法对齐的情况（1）使用vertical-align：top（2）例子： https://segmentfault.com/a/11900000109349286、em: 相对于父级元素font-size的比例。rem：相对于根元素html的font-size比例。ex：所用字体中x的高度，通常取em的一半。7、css的三种定位机制：普通流、浮动和绝对定位。position有relative、absolute、fix、staticrelative：相对于元素应该出现的位置的相对位置。absolute：绝对定位的盒子是相对于离他最近的一个已定位的盒子进行定位的，可能是relative，可能是absolute。默认是body。浮动和绝对定位都将元素剥离了文档流。8、background-origin: 取值可以为content-box、padding-box、border-box，规定背景图放置的位置。9、box盒子模型（1）ie设置的height和 width = margin + padding +content-width（2）标准的盒子模型的 width = content-width（3）css3中加了一个属性叫box-sizing 来区分上面的情况（content-box \\ border-box \\ padding-box）10、formatting context: 它是页面中的一块渲染区域、并且有自己的一套渲染规则、他决定了元素如何定位以及与其他元素如何相互作用。常见的类别有：（1）BFC (block formatting context) BFC是一个独立的区域，不受外部元素影响也不影响外部元素 只有块级元素参加 box会在垂直方向上一个接一个的放置 属于同一个BFC的相邻的两个box的margin会重叠 计算BFC高度时，浮动元素也参与计算 每个元素的margin box的左边与包含块的border box的左边相接处，存在浮动也是如此会生成BFC的方式： 根元素比如body float不为none position为absolute或者fixed display为inline-block、table-cell、table-caption、flex、inline-flex overflow为hidden、scroll、auto例子： https://www.jianshu.com/p/66632298e355（2）IFC (inline formatting context) 只会在一个块级元素中只包含内连级别元素时才会生成。 行内级元素（inline-level element）的display为inline、inline-block、inline-table 行内级元素生成行内盒（inline-level box），参与行内格式化上下文 行框的宽度由其内部包含的块以及浮动元素所决定 如果几个行内框无法放入一个行框内，他们可能分配在两个或者多个垂直的行框内 同一个行内框如果不能放入一个行框内，也会分配到多个垂直的行框 行框的高度可以容纳所包含的框，对齐标准为vertical-align（此处会引入下面的12问题）（3）GFC（4）FFC11、line-height: 设置行间的距离，可以设置的方式（1）number：以当前的字体属性值来设置行高(不同的浏览器默认值不同， 介于1 - 1.2之间)（2）百分比：以当前字体属性的百分比来设置（3）length：固定的值12、vertical-align: 默认值为baseline，即按照基线进行对齐，此值是和line-height相关的。（1）css中对基线的定义为：inline-block元素的基线是标准流中最后一个行框的基线， 除非这个行框没有行盒子或者本身overflow属性计算值不是visible，这种情况下，基线是该元素margin底边缘。（2）inline元素有两个高度：和字体相关的content-area，以及实际区域virtual-area（line-height）","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://qiongqiongwoo.github.io/blog/tags/css/"}]},{"title":"compose的执行和实现方式","slug":"compose的执行和实现方式","date":"2018-12-13T07:11:11.000Z","updated":"2019-01-04T04:04:02.000Z","comments":true,"path":"2018/12/13/compose的执行和实现方式/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/13/compose的执行和实现方式/","excerpt":"","text":"compose：执行一系列任务的函数 tasks = [ step1, step2, step3… ] Bulleted List 执行顺序从右到左边 第一个函数的参数可以是多个，后面的函数参数只能是一个 函数的执行是同步的 let init = (…args) =&gt; args.reduce((ele1, ele2) =&gt; ele1 + ele2, 0)let step2 = (val) =&gt; val + 2let step3 = (val) =&gt; val + 3let step4 = (val) =&gt; val + 4输出： 15 compose的实现（1）lodash中的实现123456789101112131415161718var flow = function（funcs）&#123; Var length = funcs.length Var index = length while (index--) &#123; if (typeof funcs[index] !== 'function') &#123; throw new TypeError('Expected a function'); &#125; &#125; Return function(…args) &#123; var index = 0 var result = length ? funcs[index].apply(this, args) : args[0] while (++index &lt; length) &#123; result = funcs[index].call(this, result) &#125; return result &#125;&#125; （2）promise实现compose12345678910const compose = function(…funcs) &#123; let init = funcs.pop() return function(...arg) &#123; return funcs.reverse().reduce(function(sequence, func) &#123; return sequence.then(function(result) &#123; return func.call(null, result) &#125;) &#125;, Promise.resolve(init.apply(null, arg))) &#125;&#125;","categories":[],"tags":[{"name":"js, node, compose","slug":"js-node-compose","permalink":"https://qiongqiongwoo.github.io/blog/tags/js-node-compose/"}]},{"title":"客户端http请求的header信息","slug":"客户端http请求的header信息","date":"2018-12-12T07:41:21.000Z","updated":"2019-01-04T02:56:21.000Z","comments":true,"path":"2018/12/12/客户端http请求的header信息/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/12/12/客户端http请求的header信息/","excerpt":"","text":"1、HTTP请求方式GET：向Web服务器请求一个文件POST：向Web服务器发送数据让Web服务器进行处理PUT：向Web服务器发送数据并存储在Web服务器内部HEAD：检查一个对象是否存在DELETE：从Web服务器上删除一个文件CONNECT：对通道提供支持TRACE：跟踪到服务器的路径OPTIONS：查询Web服务器的性能请求说明：主要使用到“GET”和“POST”。实例：POST /test/tupian/cm HTTP/1.1分成三部分：（1）POST：HTTP请求方式（2）/test/tupian/cm：请求Web服务器的目录地址（或者指令）（3）HTTP/1.1: URI（Uniform Resource Identifier，统一资源标识符）及其版本 2、Host说明：请求的web服务器域名地址实例：例如web请求URL：http://zjm-forum-test10.zjm.baidu.com:8088/test/tupian/cmHost就为zjm-forum-test10.zjm.baidu.com:8088 3、User-Agent说明：HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。实例：User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 4、Accept说明：指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。实例：例如：Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,/;q=0.5备注：在Prototyp（1.5）的Ajax代码封装中，将Accept默认设置为“text/javascript, text/html, application/xml, text/xml, /”。这是因为Ajax默认获取服务器返回的Json数据模式。在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。 5、Accept-Language说明：指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。实例：Accept-Language: zh-cn,zh;q=0.5这里默认为中文。 6、Accept-Encoding说明：指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。实例：Accept-Encoding: gzip,deflate备注：其实在百度很多产品线中，apache在给客户端返回页面数据之前，将数据以gzip格式进行压缩。另外有关deflate压缩介绍：http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/mod/mod_deflate.html 7、Accept-Charset说明：浏览器可以接受的字符编码集。实例：Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7 8、Content-Type说明：显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。实例：Content-type: application/x-www-form-urlencoded;charset:UTF-8有关Content-Type属性值可以如下两种编码类型：（1）“application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。（2）“multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。当提交为单单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。一般在开发过程，是由前端工程与后端UI工程师商量好使用什么字符编码格式来post提交的，然后后端ui工程师按照固定的字符编码来解析提交的数据。所以这里设置的charset没有多大作用。 9、Connection说明：表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。实例：Connection: keep-alive 10、Keep-Alive说明：显示此HTTP连接的Keep-Alive时间。使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。以前HTTP请求是一站式连接，从HTTP/1.1协议之后，就有了长连接，即在规定的Keep-Alive时间内，连接是不会断开的。实例：Keep-Alive: 300 11、cookie说明：HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 12、Referer说明：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面服务器端返回HTTP头部信息1、Content-Length说明：表示web服务器返回消息正文的长度2、Content-Type:说明：返回数据的类型（例如text/html文本类型）和字符编码格式。实例：Content-Type: text/html;charset=utf-83、Date说明：显示当前的时间","categories":[],"tags":[{"name":"header, http request, htttp options","slug":"header-http-request-htttp-options","permalink":"https://qiongqiongwoo.github.io/blog/tags/header-http-request-htttp-options/"}]},{"title":"ES6中的proxy和应用","slug":"ES6中的proxy和应用","date":"2018-11-14T10:18:15.000Z","updated":"2019-01-04T10:21:10.000Z","comments":true,"path":"2018/11/14/ES6中的proxy和应用/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/11/14/ES6中的proxy和应用/","excerpt":"","text":"1、ES6 中的Proxy的使用1234567891011121314151617var p = new Proxy(target, handler) // target为被包裹的对象，handler为处理方式handler能代理的方法有： get、set、has、constructvar target = &#123; a : ‘111’, ‘b’: ‘fasdf'&#125;Var newObj = Proxy(target, &#123; Set: function(target, key, value) &#123; console.log(key, ‘被设置。。。’) target[key] = value &#125;， get: function(target, key) &#123; console.log(key, ‘被读取。。。’) return target[key] &#125;&#125;)newObj.name = ‘fasdfdf’console.log(nameObj.name) 2、Proxy的应用（1）添加虚拟属性1234567891011121314151617181920212223242526var person = &#123; fisrsName: '张', lastName: '小白'&#125;;var proxyedPerson = new Proxy(person, &#123; get: function (target, key) &#123; if(key === 'fullName')&#123; return [target.fisrsName, target.lastName].join(' '); &#125; return target[key]; &#125;, set: function (target, key, value) &#123; if(key === 'fullName')&#123; var fullNameInfo = value.split(' '); target.fisrsName = fullNameInfo[0]; target.lastName = fullNameInfo[1]; &#125; else &#123; target[key] = value; &#125; &#125;&#125;);console.log('姓:%s, 名:%s, 全名: %s', proxyedPerson.fisrsName, proxyedPerson.lastName, proxyedPerson.fullName);// 姓:张, 名:小白, 全名: 张 小白proxyedPerson.fullName = '李 小露';console.log('姓:%s, 名:%s, 全名: %s', proxyedPerson.fisrsName, proxyedPerson.lastName, proxyedPerson.fullName);// 姓:李, 名:小露, 全名: 李 小露 （2）用来做私有变量隐藏12345678910111213141516171819202122232425262728293031var api = &#123; _secret: 'xxxx', _otherSec: 'bbb', ver: 'v0.0.1'&#125;;api = new Proxy(api, &#123; get: function(target, key) &#123; // 以 _ 下划线开头的都认为是 私有的 if (key.startsWith('_')) &#123; console.log('私有变量不能被访问'); return false; &#125; return target[key]; &#125;, set: function(target, key, value) &#123; if (key.startsWith('_')) &#123; console.log('私有变量不能被修改'); return false; &#125; target[key] = value; &#125;, has: function(target, key) &#123; return key.startsWith('_') ? false : (key in target); &#125;&#125;);api._secret; // 私有变量不能被访问console.log(api.ver); // v0.0.1api._otherSec = 3; // 私有变量不能被修改console.log('_secret' in api); // trueconsole.log('ver' in api); // false （3）在代理中实现属性赋值的校验1234567891011121314151617181920212223242526272829function Animal() &#123; return createValidator(this, animalValidator);&#125;var animalValidator = &#123; name: function(name) &#123; // 动物的名字必须是字符串类型的 return typeof name === 'string'; &#125;&#125;;function createValidator(target, validator) &#123; return new Proxy(target, &#123; set: function(target, key, value) &#123; if (validator[key]) &#123; // 符合验证条件 if (validator[key](value)) &#123; target[key] = value; &#125; else &#123; throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`); &#125; &#125; else &#123; target[key] = value &#125; &#125; &#125;);&#125;var dog = new Animal();dog.name = 'dog';console.log(dog.name);dog.name = 123; // Uncaught Error: Cannot set name to 123. Invalid. 3、用ES5实现Proxy1234567891011121314151617181920212223242526272829303132333435363738394041function clone(myObj)&#123; if(typeof(myObj) != 'object' || myObj == null) return myObj; var newObj = new Object(); for(var i in myObj)&#123; newObj[i] = clone(myObj[i]); &#125; return newObj;&#125;/*代理实现类*/function ProxyCopy(target,handle)&#123; var targetCopy = clone(target); Object.keys(targetCopy).forEach(function(key)&#123; Object.defineProperty(targetCopy, key, &#123; get: function() &#123; return handle.get &amp;&amp; handle.get(target,key); &#125;, set: function(newVal) &#123; handle.set &amp;&amp; handle.set(); target[key] = newVal; &#125; &#125;); &#125;) return targetCopy;&#125;var person = &#123;name:''&#125;;var personCopy = new ProxyCopy(person,&#123; get(target,key)&#123; console.log('get方法被拦截。。。'); return target[key]; &#125;, set(target,key,value)&#123; console.log('set方法被拦截。。。') // return true; &#125;&#125;)person.name = 'arvin'; // 未有拦截日志打出personCopy.name = 'arvin'; // set方法被拦截。。。console.log(person.name); // 未有拦截日志打出console.log(personCopy.name); // get方法被拦截。。。// 这个的缺点是不能检测新添加的属性 4、以上es5中的实现利用了Object.defineProperty作用123456789101112131415Object.defineProperty(obj, prop, descriptor) // 返回 objDescriptor是一个obj属性有：value： 属性值writable：是否可以重写enumerable: 是否可以被枚举configurable: 目标属性是否可以被删除或者再次修改除此之外，还有set和get属性，当给一个属性定义getter和setter时，这个属性称之为访问描述符， js会忽略他本身的value以及writable属性，取而代之的访问set和get函数。Object.defineProperty(obj, key, &#123; set: function()&#123; console.log(’set….') &#125;, get: function()&#123; console.log(‘get...') &#125;&#125;) 5、proxy在vue中的作用（实现双向绑定，即监听值的变化）","categories":[],"tags":[]},{"title":"MongoDB","slug":"MongoDB","date":"2018-11-04T10:08:15.000Z","updated":"2019-01-04T10:13:04.000Z","comments":true,"path":"2018/11/04/MongoDB/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/11/04/MongoDB/","excerpt":"","text":"NoSql非关系型数据库，常见的集中NoSql数据库有MongoDB。提到数据库不可避免的提到CAP和ACID。ACID是关系型数据库CAP三要素只可以同时实现两点，不能兼顾三者，这三者是指：一致性consistency：什么时候访问的数据都是一致的。使用Nosql必须习惯于它的弱一致性。可用性availability：一般牺牲一致性来换取高可用性。分区容忍性partition tolerance：这一点是基本要求 （1）mongoDB的特点Mongodb是时下流行的NoSql数据库，特点是高性能、开源、无模式。特点有： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序。 文件存储格式为BSON（一种JSON的扩展）。 可通过网络访问。 （2）MongoDB内部存储空间的分配首先：mongoDB中数据是以collection为单位的，其实一个collection只存储一个名字空间（包括大小，块数，第一个块的位置，最后一个块的位置，被删除的块的信息，以及索引信息）。一个collection中的数据被划分为一个个的extent，extent之间是双向链表组织的。extent中保存的信息有：自己的位置，上一个extent以及下一个extent的位置，第一条以及最后一条doc的位置。doc之间也是用双向链表进行组织的。doc中存储的是一条条的数据。 （3）索引的组织数据库索引的方式有两种，一种是hash索引一种是Btree索引。hash索引不支持对部分索引键查询，以为它是对所有的字段组合取的hash。hash索引无法避免表扫描，因为有值相等的情况。hash索引遇到大量hash值相等的情况下，效率不比Btree高。hash索引只能满足相等，大于，小于的查询，不能进行范围的查询。 （4）内存映射MMAPMongoDB是通过内存映射的方式提高性能的，因此不要在32位的机器上使用mongodb。因为32位的机器的寻址空间为4G，其中1G被内核使用，0.5G被mongoDB的栈使用，因此数据空间只有2.5G。 （5）master-slaver方式Mongodb(M)表示主节点，Mongodb(S)表示备节点，Mongodb(A)表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。默认设置下，主节点提供所有增删查改服务，备节点不提供任何服务。但是可以通过设置使备节点提供查询服务，这样就可以减少主节点的压力，当客户端进行数据查询时，请求自动转到备节点上。这个设置叫做Read Preference Modes。仲裁节点是一种特殊的节点，它本身并没有不存储数据，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。master——slaver同步的方式有：异步复制、强同步复制、以及半同步方式。异步复制是指master更新后，直接更新自己log，slaver自己同步，这种情况会出现丢信息的情况。强同步复制是指master先同步信息到slaver，全部同步成功后，再更新自己。半同步方式是指，只要成功同步的salver数目大于一个给定的值K后，master就可以同步信息到自己。 （6）replica sets红色箭头表示写操作可以写到Primary上，然后异步同步到多个Secondary上。蓝色箭头表示读操作可以从Primary或Secondary任意一个中读取。各个Primary与Secondary之间一直保持心跳同步检测，用于判断Replica Sets的状态。（7）chunkMongoDB的分片是指定一个分片key来进行，数据按范围分成不同的chunk，每个chunk的大小有限制。有多个分片节点保存这些chunk，每个节点保存一部分的chunk。每一个分片节点都是一个Replica Sets，这样保证数据的安全性。当一个chunk超过其限制的最大体积时，会分裂成两个小的chunk。当chunk在分片节点中分布不均衡时，会引发chunk迁移操作(move chunk)。 （8）sharding（分片）sharding是将一个大数据库按照一定规则拆分成多个小数据库的一门技术。常用的sharding方案有以下几种，按功能划分（垂直切分）将不同功能相关的表放到不同的数据库中，譬如将用户管理相关表放到shard 1上，将blog相关表放到shard 2上。。。这样做的好处是非常直观，当需要用户列表时，我就到shard 1上获取。。。。这样也有一个问题，当某一部分的功能其数据量或性能要求超出了可控的范围，我们就需要继续对其进行深入的sharding。按表中某一字段值的范围划分（水平切分）当伴随着某一个表的数据量越来越大，以至于不能承受的时候，就需要对她进行进一步的切分。一种选择是根据key的范围来做切分，譬如userID为1-10000的放到shard 10上，userID为10000到20000的放到shanrd 11上。。。这样的扩展就是可预见的。另一种是根据某一字段值得来划分，譬如根据用户名的首字母，如果是a-d，就属于shard 20，e-h就属于shard 21。。。这样做也存在不均衡性，当某个范围超出了shard所能承受的范围就需要继续切分。还有按日期切分等等，基于hash的切分类似于memcached的key hash算法，一开始确定切分数据库的个数，通过hash取模来决定使用哪台shard。这种方法能够平均的来分配数据，但是伴随着数据量的增大，需要进行扩展的时候，这种方式无法做到在线扩容。每增加节点的时候，就需要对hash算法重新运算，数据需要重新割接。基于路由表的切分前面的几种方式都是跟据应用的数据来决定操作的shard，基于路由表的切分是一种更加松散的方法。它单独维护一张路由表，根据用户的某一属性来查找路由表决定使用哪个shard，这种方式是一种更加通用的方案。譬如我们在系统中维护一张表-（用户所属省-〉shard），这样每个用户我们知道是哪个省的，去路由表查找，就知道它所在的shard。因为每次数据操作的时候都需要进行路由的查找，所以将这些内容存储到一台独立cache上是一个非常好的方式，譬如memcached。这种切分的方式同时也带来了另一个好处，当需要增加shard的时候，可以在不影响在线应用的情况下来执行，当然这也跟应用程序的架构设计相关，你的设计必须适用这种增加。虽然应用sharding会带来显而易见的好处，但是它也有一些固有的问题需要我们了解，这些问题大致分成以下几类，1。shard的扩容当当前的shard已经不能适用当前的应用需求时，就需要对shard数据库进行扩容，增加shard意味着需要对原有的shard数据进行迁移，这个过程是非常复杂，而且可能会导致数据的不一致（一边写、一边迁移）或者其他应用问题，因此扩容一般选择在凌晨等时间进行。2。联合多个shard的表数据查询这个是shard固有的问题，当遇到这样的问题时，你需要获取各个shard的数据，然后对这些数据进行汇总，很多时候因为现在的网络速度比较发达这个问题可以几乎被忽略掉。但是如果要进行数据的分析或挖掘，shard就会存在问题，通常面对这种对于数据要求不是那么实时的情况下，可以采用将shard数据同步到汇总数据库的方案，olap可以在这台汇总数据库上进行，这就需要在每台shard上进行数据的定时同步，这增加了程序的复杂性；如果要求实时的情况下，采用sharding方案会是一个毁灭性打击。3。其他我们现在做的系统就是采用的按照路由表切分的sharding方案，而且我们需要要求不是那么实时的汇总数据以提供数据的分析和挖掘，同时我们的基础数据都是在汇总数据库中进行管理，通过oracle的高级复制到shard节点上。在shard数据库向汇总数据库同步数据的时候，我们是通过oracle数据库的存储过程实现的，这种架构方式导致了数据库非常的复杂，同时还存在了一些其他问题，譬如同步会无缘无故的断掉。。。这就需要采用一些其他手段来维持数据的延迟一致性。(9) mongosmongos是路由节点，客户端通过mongos来进行读写。config服务器保存了两个映射关系，一个是key值的区间对应哪一个chunk的映射关系，另一个是chunk存在哪一个分片节点的映射关系。路由节点通过config服务器获取数据信息，通过这些信息，找到真正存放数据的分片节点进行对应操作。路由节点还会在写操作时判断当前chunk是否超出限定大小。如果超出，就分列成两个chunk。对于按分片key进行的查询和update操作来说，路由节点会查到具体的chunk然后再进行相关的工作。对于不按分片key进行的查询和update操作来说，mongos会对所有下属节点发送请求然后再对返回结果进行合并。（10）具体的例子：(11) mongodb的安全权限设置mongodb默认是没有用户名和口令的,启动后,可以直接用mongoDB连接,并且对所有的库具有root权限,为了安全,必须给其设置用户名和口令.只需要再启动的时候,指定auth参数.就可以阻止客户端的访问和连接,如下123456789101112131415161718eg.&gt;mongod -auth --dbpath=../data --logpath=../logs/mongodb.logs想要登录验证模块生效,必须在admin库中添加一个用户,同时要指定auth参数.D:\\program files\\mongo\\bin&gt;mongoMongoDB shell version: 1.8.1connecting to: test]]&gt; use adminswitched to db admin&gt; db.addUser(\"root\",\"root123\");&#123; \"user\" : \"root\", \"readOnly\" : false, \"pwd\" : \"81c5bca573e01b632d18a459c6cec418\"&#125;&gt; db.auth(\"root\",\"root123\");1&gt; 此时建立了系统root用户.也可以对某个特定的数据库设置用户,这样权限的细粒度划分,也方便进行用户管理.注意:建立指定权限的用户只能用系统用户来操作.","categories":[],"tags":[]},{"title":"JS中class深入","slug":"JS中class深入","date":"2018-10-11T10:24:27.000Z","updated":"2019-01-04T10:28:54.000Z","comments":true,"path":"2018/10/11/JS中class深入/","link":"","permalink":"https://qiongqiongwoo.github.io/blog/2018/10/11/JS中class深入/","excerpt":"","text":"1、es6中的class（1）es6中定义一个class的实例1234567891011121314151617181920class Person&#123; constructor(name)&#123; this.name = name &#125; Hello2 = () =&gt; &#123; // console.log(‘hello 2 是原型方法，每个实例对象都包含一个，而不是放在__proto——中的') &#125; hello()&#123; console.log('my name is'+this.name) &#125;&#125;var xiaoming = new Person('xiaoming')xiaoming.hello() // my name is xiaomingvar lisi = new Person(‘lisi')lisi.hello() // my name is lisitypeof Person // functionxiaoming.__proto__ === lisi.__proto__ // truexiaoming.__proto__ === Person.prototype // trueXiaoming.hello = Person.prototype.hello // true Es5中定义的类中的方法和es6中定义的类中的方法的区别： Es5中定义的方法是可以枚举的Object.keys(Person1.__proto) : [‘hello’], 而es6中的不可以枚举 es6中的方法定义时不要带function且方法名可以用参数 Es6中的class和5中的区别并不大，只是一个语法糖（便于书写的东西） 在ES6里如果要使用super使用父类的同名方法，父类的方法不能设置为实例方法（2）Person结构（3）es5中创建一个类的方式1234567891011121314function Person(name) &#123; // 以function的形式创建类 this.name = name&#125;Person.prototype.describe = function()&#123; console.log('my name is'+this.name)&#125;var jany = new Person('jany')jany.__proto__ === Person.prototype // truejany.describe()function superMan(name,age)&#123; Person.call(this,name) // Person.apply(this, args) this.age = age&#125;superMan.prototype = Object.create(Person.prototype) // Objcet.create是用创建一个新的obj，并将obj.__proto__指向当前的obj。 以上代码执行的过程为 首先给Person.prototype属性所指的原型对象上添加一个方法describe 在使用new关键字创建对象时，会默认给当前对象添加一个原型属性proto并指向Person.prototype 在读取describe时候，jany本身并不包含该方法，于是到原型链上去查找。（4）js中object中包含两部分：普通属性和原型属性proto，从结构中可以看到proto仍然是一个对象，即原型对象。而prototype是function独有的属性，再调用new时用来生成proto。constructor是比较特殊的属性，用来指向类本身。（5）object function之间的关系图(Object和Function互为实例)（6）es6中extends的实现123456789101112131415161718192021class Foo &#123; constructor(who)&#123; this.me = who; &#125; identify()&#123; return \"I am \" + this.me; &#125;&#125;class Bar extends Foo &#123; constructor(who)&#123; // super() 指的是调用父类 （super关键字指代父类的实例即this对象） // 调用的同时，会绑定 this 。 // 如：Foo.call(this, who) super(who); &#125; speak() &#123; alert( \"Hello, \" + this.identify() + \".\" ); &#125;&#125;var b1 = new Bar( \"b1\" );b1.speak(); Foo和Bar的关系图如下（可以看到Bar的prototype是Foo的一个实例，在Bar的prototype中找不到的属性到Foo中去找）（7）instance of的原理：检测左侧的proto原型链上是不是存在右侧的prototype1L instanceof R // L.__proto__.__proto__….. === R.prototype （8） es6之前没有类的概念，为了实现继承需要采用一些手段， 以下描述了类继承的一些进展1、通过原型链继承 - js原型链条的特性导致如果一个object中找不到当前属性可以按照prototype往上找，因此为了实现继承，可以将child的prototype设置为parent的一个实例。12345678910111213141516function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function()&#123; console.log(‘parent name’, this.name)&#125;function Child(name) &#123; this.name = name;&#125;Child.prototype = new Parent(‘zhang’);Child.prototype.constructor = Child;Child.prototype.sayName = function() &#123; console.log(‘child name’, this.name)&#125;var child = new Child(’son’);child.sayName(); // parent个人的一些属性对于child的多个实体来说是一份 2、为了解决上面的属性不能继承的问题，可以利用类继承的方式1234567891011121314function Parent(name) &#123; this.name = name;console.log('set parent name', name);&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;Parent.prototype.doSomthing = function() &#123; console.log('parent do something!');&#125;function Child(name, parentName) &#123; Parent.call(this, parentName); this.child_name = name;&#125;var child = new Child('son’); child有两个属性分别为name和child_name，但是方法确继承不下来了。 3、将上面属性继承和方法继承组合在一起12345678910111213141516function Parent(name) &#123; this.parent_name = name;&#125;Parent.prototype.sayName = function()&#123; console.log('parent name', this.name)&#125;function Child(chiild_name, parent_name) &#123; Parent.call(this, parent_name) this.child_name = chiild_name;&#125;Child.prototype = new Parent('zhang');Child.prototype.constructor = Child;Child.prototype.sayName = function() &#123; console.log('child name', this.name)&#125;var child = new Child('son', 'li'); 此时既做到了属性继承也做到了方法继承， child的结构为： 4、上述两次冗余的地方目的是为了将子类的prototype的proto指向父类，因此可以创建一个空函数， 空函数的prototype指向parent的prototype，而子类为此空函数的子类即可。1Child.prototype = new Parent('zhang’); 可以升级为 child.prototype = Object.create(Parent.prototype) 阿拉蕾的class实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// The base Class implementation.function Class(o) &#123; //这个判断用来支持 将一个已有普通类转换成 阿拉蕾的类 if (!(this instanceof Class) &amp;&amp; isFunction(o)) &#123; //原理是给这个函数增加extend，implement方法 return classify(o) &#125;&#125;//用于创建一个类，第一个参数可选，可以直接创建时就指定继承的父类。//第二个参数也可选，用来表明需要混入的类属性。//有三个特殊的属性为Extends,Implements,Statics.分别代表要继承的父类，需要混入原型的东西，还有静态属性。Class.create = function(parent, properties) &#123; //创建一个类时可以不指定要继承的父类。直接传入属性对象。 if (!isFunction(parent)) &#123; properties = parent parent = null &#125; properties || (properties = &#123;&#125;) //没有指定父类的话 就查看有没有Extends特殊属性，都没有的话就用Class作为父类 parent || (parent = properties.Extends || Class) properties.Extends = parent // 子类构造函数的定义 function SubClass() &#123; // 自动帮忙调用父类的构造函数 parent.apply(this, arguments) // Only call initialize in self constructor. //真正的构造函数放在initialize里面 if (this.constructor === SubClass &amp;&amp; this.initialize) &#123; this.initialize.apply(this, arguments) &#125; &#125; // Inherit class (static) properties from parent. // parent为Class就没必要混入 if (parent !== Class) &#123; //将父类里面的属性都混入到子类里面这边主要是静态属性 mix(SubClass, parent, parent.StaticsWhiteList) &#125; // Add instance properties to the subclass. // 调用implement将自定义的属性混入到子类原型里面。遇到特殊值会单独处理，真正的继承也是发生在这里面 //这边把属性也都弄到了原型上，因为这边每次create或者extend都会生成一个新的SubClass。 //所以倒也不会发生属性公用的问题。但是总感觉不大好 implement.call(SubClass, properties) // Make subclass extendable. //给生成的子类增加extend和implement方法，可以在类定义完后，再去继承，去混入其他属性。 return classify(SubClass)&#125;// Create a sub Class based on `Class`.Class.extend = function(properties) &#123; properties || (properties = &#123;&#125;) //定义继承的对象是自己 properties.Extends = this //调用Class.create实现继承的流程 return Class.create(properties)&#125;// 这里定义了一些特殊的属性，阿拉蕾遍历时发现key是这里面的一个时，会调用这里面的方法处理。Class.Mutators = &#123; //这个定义了继承的真正操作代码。 'Extends': function(parent) &#123; //这边的this指向子类 var existed = this.prototype //生成一个中介原型，就是之前我们实现的objectCreat var proto = createProto(parent.prototype) //将子类原型有的方法混入到新的中介原型上 mix(proto, existed) // 改变构造函数指向子类 proto.constructor = this // 改变原型 完成继承 this.prototype = proto //为子类增加superclass属性，这样可以调用父类原型的方法。 this.superclass = parent.prototype &#125;, //这个有点类似组合的概念，支持数组。将其他类的属性混入到子类原型上 'Implements': function(items) &#123; isArray(items) || (items = [items]) var proto = this.prototype, item while (item = items.shift()) &#123; mix(proto, item.prototype || item) &#125; &#125;, //传入静态属性 'Statics': function(staticProperties) &#123; mix(this, staticProperties) &#125;&#125;// Shared empty constructor function to aid in prototype-chain creation.function Ctor() &#123;&#125;// 用于在类定义之后，往类里面添加方法。提供了之后修改类的可能。// 类似上面defjs实现的open函数。function implement(properties) &#123; var key, value for (key in properties) &#123; value = properties[key] //发现属性是特殊的值时，调用对应的处理函数处理 if (Class.Mutators.hasOwnProperty(key)) &#123; Class.Mutators[key].call(this, value) &#125; else &#123; this.prototype[key] = value &#125; &#125;&#125;//给一个普通的函数 增加extend和implement方法。function classify(cls) &#123; cls.extend = Class.extend cls.implement = implement return cls&#125;//用来支持 commonjs的模块规范。module.exports = Class// 使用// Create a new Class.// var SuperPig = Class.create(&#123;// Extends: Animal,// Implements: Flyable,// initialize: function() &#123;// SuperPig.superclass.initialize.apply(this, arguments)// &#125;,// Statics: &#123;// COLOR: 'red'// &#125;// &#125;)//// 这个方法就是我们之前实现的objectCreat，用来使用一个中介者来处理原型的问题，// 当浏览器支持`__proto__`时可以直接使用。// 否则新建一个空函数再将父类的原型赋值给这个空函数，返回这个空函数的实例var createProto = Object.__proto__ ? function(proto) &#123; return &#123; __proto__: proto &#125; &#125; : function(proto) &#123; Ctor.prototype = proto return new Ctor() &#125;// Helpers 下面都是些辅助方法，很简单就不说了function mix(r, s, wl) &#123; // Copy \"all\" properties including inherited ones. for (var p in s) &#123; //过滤掉原型链上面的属性 if (s.hasOwnProperty(p)) &#123; if (wl &amp;&amp; indexOf(wl, p) === -1) continue // 在 iPhone 1 代等设备的 Safari 中，prototype 也会被枚举出来，需排除 if (p !== 'prototype') &#123; r[p] = s[p] &#125; &#125; &#125;&#125;","categories":[],"tags":[]}]}